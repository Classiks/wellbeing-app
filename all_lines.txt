import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:duration_picker/duration_picker.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/reusable/set_input.dart';


class ActivityDateAndDuration extends ConsumerWidget {
  const ActivityDateAndDuration({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(selectedDateProvider.state).state = todayStart;
      ref.read(selectedDurationProvider.state).state = defaultDuration;
    });

    return Column(children: const [
      DatePicker(),
      SizedBox(height: 10,),
      DurationPicker()
    ],);
  }
}


class DatePicker extends SetInput {
  const DatePicker({super.key}) : super(
      label: 'Date',
      input: const DateButton()
  );
}


class DateButton extends ConsumerWidget {
  const DateButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final DateTime today = DateTime.now();
    final DateTime todayStart = DateTime(today.year, today.month, today.day);
    final DateTime selectedDate = ref.watch(selectedDateProvider);
    final String selectedDateString = DateFormat.yMd().format(selectedDate);
    final DateTimeRange dateRangeForSelection = ref.read(dateRangeForSelectionBounds);

    return ElevatedButton(
        onPressed: () async {
          final DateTime? date = await showDatePicker(
            context: context,
            initialDate: todayStart,
            firstDate: dateRangeForSelection.start,
            lastDate: dateRangeForSelection.end,
            helpText: 'Select a date'
          );

          if (date == null) return;

          ref.read(selectedDateProvider.state).state = date;
        },
        child: Text(selectedDateString)
      );
  }
}


class DurationPicker extends SetInput {
  const DurationPicker({super.key}): super(
      label: 'Duration',
      input: const DurationButton()
  );
}

class DurationButton extends ConsumerWidget {
  const DurationButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final int startDuration = ref.watch(selectedDurationProvider);

    return ElevatedButton(
      onPressed: () async {
        final Duration? duration = await showDurationPicker(
          context: context,
          initialTime: Duration(minutes: startDuration),
        );

        if (duration == null) return;

        final int durationInMinutes = duration.inMinutes;

        ref.read(selectedDurationProvider.state).state = durationInMinutes;
      },
      child: Text('${ref.watch(selectedDurationProvider)} Minutes')
    );
  }
}



class ActivityTypePickerOption {
  ActivityTypePickerOption(this.activityTypeId, this.isFavorite);
  
  String activityTypeId;
  bool isFavorite;
}

class ActivityTypePickerOptionWithHighlight extends ActivityTypePickerOption {
  ActivityTypePickerOptionWithHighlight(super.activityTypeId, super.isFavorite, this.doHighlight);

  ActivityTypePickerOptionWithHighlight.fromBaseOption(ActivityTypePickerOption baseEntry, this.doHighlight) : super(
    baseEntry.activityTypeId,
    baseEntry.isFavorite
  );

  final bool doHighlight;
}import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/activity_logging/activity_type_option.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/components/activity_logging/optional_highlight_icon.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';


final StateProvider<bool> showAddNewActivityTypeButtonProvider = StateProvider((ref) => false);


class ActivityTypePickerWithInput extends ConsumerWidget {
  ActivityTypePickerWithInput({super.key});

  late BuildContext buildContext;
  late Reader stateReader;
  late Reader stateWatcher;
  late ActivityTypeCollection activityTypes;
  late Set<String> favorites;
  late int numberOfFavorites;
  late List<ActivityTypePickerOptionWithHighlight> fullOptions;
  late FocusNode textFieldFocusNode;
  late bool showFavorites;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    buildContext = context;
    stateReader = ref.read;
    stateWatcher = ref.watch;
    activityTypes = ref.watch(activityTypeCollectionProvider);
    favorites = ref.watch(favoriteActivityTypesProvider);
    numberOfFavorites = favorites.length;

    final AppSettings appSettings = ref.watch(appSettingsProvider);
    showFavorites = appSettings.showFavoriteActivities;

    fullOptions = createPickerOptions();


    return Autocomplete(
      optionsBuilder: returnMatchingOptions, 
      displayStringForOption: (ActivityTypePickerOptionWithHighlight option) {
        return activityTypes.getNameByIdOrReturnDefault(option.activityTypeId);
      },
      onSelected: (ActivityTypePickerOptionWithHighlight option) => onOptionSelectedAndUnfocus(option.activityTypeId),
      fieldViewBuilder: buildTextField,
      optionsViewBuilder: buildOptionsWidgets
    );
  }

  void onOptionSelected(String id) {
    stateReader(activityTypeIdProvider.state).state = id;
    stateReader(showAddNewActivityTypeButtonProvider.state).state = false;
  }

  void onOptionSelectedAndUnfocus(String id) {
    onOptionSelected(id);
    textFieldFocusNode.unfocus();
  }
  
  FutureOr<Iterable<ActivityTypePickerOptionWithHighlight>> returnMatchingOptions(TextEditingValue value) {
    String text = value.text;
    if (text.isEmpty) return fullOptions;
    
    return fullOptions.where(
      (e) {
        final String nameLower = activityTypes
          .getNameByIdOrReturnDefault(e.activityTypeId)
          .toLowerCase();

        return nameLower.contains(text.toLowerCase());
      }
    );
  }

  List<ActivityTypePickerOptionWithHighlight> createPickerOptions() {
    List<ActivityTypePickerOption> options = activityTypes
      .values
      .map((e) => ActivityTypePickerOption(e.id, favorites.contains(e.id)))
      .toList();

    options.sort(
      (a, b) {
        String nameA = activityTypes.getNameByIdOrReturnDefault(a.activityTypeId);
        String nameB = activityTypes.getNameByIdOrReturnDefault(b.activityTypeId);
        return nameA.toLowerCase().compareTo(nameB.toLowerCase());
      }  
    );

    Iterable<ActivityTypePickerOptionWithHighlight> optionOnTopHighlighted = options
      .where((e) => e.isFavorite)
      .map((e) => ActivityTypePickerOptionWithHighlight.fromBaseOption(e, true));

    Iterable<ActivityTypePickerOptionWithHighlight> optionsFullNotHighlighted = options
      .map((e) => ActivityTypePickerOptionWithHighlight.fromBaseOption(e, false));

    if (showFavorites) {
      return [...optionOnTopHighlighted, ...optionsFullNotHighlighted];
    }

    return optionsFullNotHighlighted.toList();

  }

  Widget buildTextField(
    BuildContext context, TextEditingController fieldTextEditingController,
    FocusNode fieldFocusNode, VoidCallback onFieldSubmitted
  ) {
    textFieldFocusNode = fieldFocusNode;
    final bool showAddNewActivityTypeButton = stateWatcher(showAddNewActivityTypeButtonProvider);

    return TextField(
      controller: fieldTextEditingController,
      focusNode: fieldFocusNode,
      autofocus: true,
      style: const TextStyle(fontWeight: FontWeight.bold),
      decoration: InputDecoration(
          suffixIcon: showAddNewActivityTypeButton
            ? AddNewActivityTypeButton(() {
              addNewActivityType(fieldTextEditingController.text);
            })
            : null
        ),
      onChanged: (value) => typing(value),
    );
  }

  void typing(String text) {
    String? existingName = activityTypes.getNameByNameOrNull(text);
    bool nameExists = existingName != null;
    
    final bool isNewActivityTypeAndNotEmpty = (
      !nameExists &&
      text.isNotEmpty
    );
    stateReader(showAddNewActivityTypeButtonProvider.state).state = isNewActivityTypeAndNotEmpty;

    if (nameExists) {
      ActivityType matchingActivityType = activityTypes.getByNameOrReturnDefault(existingName);
      onOptionSelected(matchingActivityType.id);
    } else {
      stateReader(activityTypeIdProvider.state).state = null;
    }
    
    stateReader(activityTypeNameInputProvider.state).state = existingName ?? text;
  }

  Widget buildOptionsWidgets(
    BuildContext context,
    AutocompleteOnSelected<ActivityTypePickerOptionWithHighlight> onSelected,
    Iterable<ActivityTypePickerOptionWithHighlight> options
  ) {
    ActivityTypeListView optionListView = ActivityTypeListView(
      options: options,
      separatorBuilder: separatorBuilder,
      itemBuilder: (BuildContext context, int index) {
        return itemBuilder(index, options, onSelected);
      }
    );

    return Align(
      alignment: Alignment.topLeft,
      child: Material(child: Padding(
        padding: const EdgeInsets.fromLTRB(10, 0, 10, 10),
        child: OptionList(
          height: 400,
          backgroundColor: Theme.of(context).colorScheme.background,
          child: optionListView,
        ),
      ),),
    );
  }


  void addNewActivityType(String activityTypeName) {
    Set<String> existingIds = activityTypes.getExistingIds();
    String newId = createUniqueId(existingIds);
    onOptionSelectedAndUnfocus(newId);
  }

  Widget separatorBuilder(BuildContext context, int index) {
    if (showFavorites && index == numberOfFavorites-1) {
      return Divider(color: Theme.of(context).colorScheme.primary,);
    }
    return const Divider(color: Colors.grey,);
  }

  Widget itemBuilder(
    int index,
    Iterable<ActivityTypePickerOptionWithHighlight> options,
    AutocompleteOnSelected<ActivityTypePickerOptionWithHighlight> onSelected
  ) {
    final ActivityTypePickerOptionWithHighlight option = options.elementAt(index);
    return Option(
      activityTypes.getByIdOrReturnDefault(option.activityTypeId),
      option.doHighlight,
      onTap: () => onSelected(option)
    );
  }
}

class AddNewActivityTypeButton extends IconButton {
  const AddNewActivityTypeButton(VoidCallback addFunction, {super.key}) : super(
      icon: const Icon(Icons.add),
      onPressed: addFunction
  );
}

class Option extends GestureDetector {
  Option(
    ActivityType activityType,
    bool doHighlight,
    {
      super.key,
      super.onTap,
    }
  ) : super(
    behavior: HitTestBehavior.translucent,
    child: Row(
      mainAxisSize: MainAxisSize.max,
      children: [
        Icon(
          activityType.icon, 
          color: activityType.color,
        ),
        const SizedBox(width: 10,),
        Text(
          activityType.name,
        ),
        const SizedBox(width: 10,),
        const Expanded(child: SizedBox()),
        OptionalHighlightIcon(doHighlight)
      ],
    )
  );
}


class OptionList extends Container {
  OptionList({
    super.key,
    super.width,
    super.height,
    super.child,
    Color? backgroundColor
  }): super(
    decoration: BoxDecoration(
        color: backgroundColor,
        border: Border.all(color: Colors.grey),
        borderRadius: const BorderRadius.all(Radius.circular(20))
      ),
  );
}


class ActivityTypeListView extends ListView {
  ActivityTypeListView({
    super.key,
    required this.options,
    required super.separatorBuilder,
    required super.itemBuilder
  }) : super.separated(
    padding: const EdgeInsets.all(10.0),
    itemCount: options.length,
  );

  final Iterable<ActivityTypePickerOptionWithHighlight> options;
}



import 'package:flutter/material.dart';

class OptionalHighlightIcon extends StatelessWidget {
  const OptionalHighlightIcon(this.doHighlight, {super.key});

  final bool doHighlight;

  @override
  Widget build(BuildContext context) {
    if (doHighlight) {
      return const Icon(
        Icons.favorite,
        color: Colors.red
      );
    }

    return Container();
  }
}class Option {
  Option(this.option, this.isFavorite);
  
  String option;
  bool isFavorite;
}

class OptionWithHighlight extends Option {
  OptionWithHighlight(Option option, this.isSelected) : super(
    option.option, option.isFavorite
  );

  bool isSelected;
}class AxisBounds {
  AxisBounds(this.lower, this.higher) {
    final double padding = get15PercentOfRange(lower, higher);
    lowerWithPadding = lower - padding;
    higherWithPadding = higher + padding;
  }

  final double lower;
  final double higher;
  late final double lowerWithPadding;
  late final double higherWithPadding;
}


get15PercentOfRange(double min, double max, [double minReturn = 1]) {
  final double padding = (max - min) * 0.15;
  return padding > minReturn ? padding : minReturn;
}import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:wellbeing/dataclasses/color_gradient.dart';


class WellbeingAxis extends AxisTitles {
  WellbeingAxis(ColorGradient gradient) : super(
    sideTitles: SideTitles(
      showTitles: true,
      reservedSize: 35,
      interval: 20,
      getTitlesWidget: (value, meta) => createWellbeingAxisTicks(value, meta, gradient)
    ),
  );
}

Widget createWellbeingAxisTicks(double value, TitleMeta meta, ColorGradient gradient) {
  if (value < 0 || value > 100) {
    return Container();
  }
  
  return SideTitleWidget(
    axisSide: meta.axisSide,
    space: 10,
    child: Text(
      value.toStringAsFixed(0),
      style: TextStyle(
        color: gradient.getColorAtPercentOpaque(value/100)
      ),
    ),
  );
}


class DurationAxis extends AxisTitles {
  DurationAxis(double lower, double higher, {bool showMinValue = false}) : super(
    sideTitles: SideTitles(
      showTitles: true,
      reservedSize: 35,
      interval: (higher-lower)/5, // why more than 6
      getTitlesWidget: (value, meta) => createDurationAxisTicks(value, meta, showMinValue)
    ),
  );
}


Widget createDurationAxisTicks(double value, TitleMeta meta, bool showMinValue) {
  if (value < 0 || value == meta.max) {
    return Container();
  }

  if (!showMinValue && value == meta.min) {
    return Container();
  }

  bool needsDecimal = (meta.max - meta.min) < 10;  // hardcoded 10 => same in Axis Classes
  int decimalPlaces = needsDecimal ? 1 : 0;

  return SideTitleWidget(
    axisSide: meta.axisSide,
    child: Text(value.toStringAsFixed(decimalPlaces)),
  );
}import 'dart:math';

import 'package:flutter/material.dart';
import 'package:wellbeing/dataclasses/activity_type_summary.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/components/charts/axis_bounds.dart';
import 'package:wellbeing/components/charts/axis_ticks.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:wellbeing/dataclasses/color_gradient.dart';
import 'package:wellbeing/components/reusable/color_gradient_from_settings.dart';

class BarChartColumn extends ConsumerWidget {
  const BarChartColumn({
    super.key,
    required this.summaryList,
    required this.types,
    required this.durationBounds,
    required this.wellbeingBounds
  });

  final List<ActivityTypeSummary> summaryList;
  final ActivityTypeCollection types;
  final AxisBounds durationBounds;
  final AxisBounds wellbeingBounds;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);
    final ColorGradient colorGradient = colorGradientFromAppSettings(appSettings); 

    final Size screenSize = MediaQuery.of(context).size;
    final double aspectRatio = screenSize.width / (screenSize.height*0.35);

    return Padding(
      padding: const EdgeInsets.only(left: 10, right: 10),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          AspectRatio(
            aspectRatio: aspectRatio,
            child: MetricBarChart(
              summaryList: summaryList,
              types: types,
              yAxisBounds: wellbeingBounds,
              yAxisTicks: WellbeingAxis(colorGradient),
              getMetric: (summary) => summary.getWellbeingAverage(),
              leftAxisText: "Wellbeing",	
            ),
          ),
          AspectRatio(
            aspectRatio: aspectRatio,
            child: MetricBarChart(
              summaryList: summaryList,
              types: types,
              yAxisBounds: durationBounds,
              yAxisTicks: DurationAxis(0, durationBounds.higherWithPadding, showMinValue: true),
              getMetric: (summary) => summary.getDurationSum(),
              leftAxisText: "Duration (in Minutes)",	
            ),
          ),
        ],
      ),
    );
  }
}





class MetricBarChart extends ConsumerWidget {
  const MetricBarChart({
    super.key,
    required this.summaryList,
    required this.types,
    required this.getMetric,
    required this.yAxisBounds,
    required this.yAxisTicks,
    required this.leftAxisText
  });
  
  final List<ActivityTypeSummary> summaryList;
  final ActivityTypeCollection types;
  final AxisBounds yAxisBounds;
  final AxisTitles yAxisTicks;
  final double Function(ActivityTypeSummary) getMetric;
  final String leftAxisText;

  @override
  Widget build(BuildContext context, WidgetRef ref) {

    return BarChart(
        BarChartData(
          minY: 0,
          maxY: yAxisBounds.higherWithPadding,
          barGroups: summaryList.map((summary) {
            final int index = summaryList.indexOf(summary);

            return BarChartGroupData(
              x: index,
              barRods: [
                BarChartRodData(
                  fromY: 0,
                  toY: getMetric(summary),
                  width: 40,
                  color: types.getColorByIdOrReturnDefault(summary.id),
                  borderRadius: BorderRadius.circular(5),
                ),
              ],
            );
          }).toList(),
          titlesData: FlTitlesData(
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                getTitlesWidget: (value, meta) {
                  final int index = value.toInt();
                  final ActivityTypeSummary summary = summaryList.elementAt(index);
                  final String name = types.getNameByIdOrReturnDefault(summary.id);
                  return RotatedBox(
                    quarterTurns: 1,
                    child: Text(name),
                  );
                },
                reservedSize: 120
              ),
            ),
            rightTitles: yAxisTicks,
            topTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
            leftTitles: AxisTitles(axisNameWidget: Text(leftAxisText),),
          )
        ),
      );
  }
}import 'package:flutter/material.dart';
import 'package:wellbeing/dataclasses/activity_type_summary.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/dataclasses/color_gradient.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:wellbeing/components/reusable/color_gradient_from_settings.dart';


class DurationWellbeingPieChart extends ConsumerWidget {
  const DurationWellbeingPieChart({
    super.key,
    required this.summaryList,
    required this.types,
    this.showLabels = true
  });

  final List<ActivityTypeSummary> summaryList;
  final ActivityTypeCollection types;
  final bool showLabels;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);
    final ColorGradient colorGradient = colorGradientFromAppSettings(appSettings); 


    return PieChart(
      PieChartData(
        startDegreeOffset: 0,
        borderData: FlBorderData(
          show: false,
        ),
        sectionsSpace: 1,
        centerSpaceRadius: 0,
        sections: summaryList.reversed.map((summary) {
          return PieChartSectionData(
            color: colorGradient.getColorAtPercentOpaque(summary.wellbeingAverage/100),
            value: summary.durationSum,
            title: types.getNameByIdOrReturnDefault(summary.id),
            showTitle: showLabels,
            radius: 150,
            titleStyle: const TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: Color(0xffffffff),
            ),
          );
        }).toList()
      )
    );
  }
}import 'package:flutter/material.dart';
import 'package:wellbeing/components/charts/duration_wellbeing_pie_chart.dart';
import 'package:wellbeing/components/reusable/rich_text_adaptive.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/dataclasses/activity_type_summary.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/dataclasses/color_gradient.dart';
import 'package:wellbeing/components/reusable/color_gradient_from_settings.dart';
import 'package:wellbeing/components/reusable/rich_text_adaptive.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';

class DurationWellbeingPieChartWithIndicators extends ConsumerWidget {
  const DurationWellbeingPieChartWithIndicators({
    super.key,
    required this.summaryList,
    required this.types
  });

  final List<ActivityTypeSummary> summaryList;
  final ActivityTypeCollection types;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.read(appSettingsProvider);
    final ColorGradient colorGradient = colorGradientFromAppSettings(appSettings); 
    final double totalDuration = summaryList.fold(
      0, 
      (double sum, ActivityTypeSummary summary) => sum + summary.durationSum
    );

    return SingleChildScrollView(
      child: Column(
        children: [
          AspectRatio(
            aspectRatio: 1,
            child: DurationWellbeingPieChart(
              summaryList: summaryList,
              types: types,
              showLabels: false,
            ),
          ),
          Column(
            children: summaryList
              .map((e) {
                final ActivityType type = types.getByIdOrReturnDefault(e.id);              
                return Indicator(
                  typeColor: type.color,
                  wellbeingColor: colorGradient.getColorAtPercentOpaque(e.wellbeingAverage/100),
                  name: type.name,
                  wellbeingAverage: e.wellbeingAverage,
                  timeShare: e.durationSum/totalDuration,
                );
              })
              .toList(),
          )
        ],
      ),
    );
  }
}


class Indicator extends StatelessWidget {
  const Indicator({
    super.key,
    required this.typeColor,
    required this.wellbeingColor,
    required this.name,
    required this.wellbeingAverage,
    required this.timeShare
  });

  final String name;
  final Color typeColor;
  final Color wellbeingColor;
  final double wellbeingAverage;
  final double timeShare;

  @override
  Widget build(BuildContext context) {
    final String timeSharePercentString = (timeShare*100).toStringAsFixed(2);
    final String wellbeingAverangeString = wellbeingAverage.toStringAsFixed(2);

    return Padding(
      padding: const EdgeInsets.only(bottom: 10),
      child: Row(
        children: [
          const Spacer(),
          Container(
            width: 16,
            height: 16,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: wellbeingColor,
            ),
          ),
          const SizedBox(
            width: 4,
          ),
          RichTextAdaptive(
            children: [
              TextSpan(
                text: name,
                style: TextStyle(
                  color: typeColor,
                ),
              ),
              const TextSpan(text: ' (Wellbeing Average of '),
              TextSpan(
                text: wellbeingAverangeString,
                style: TextStyle(
                  color: wellbeingColor,
                ),
              ),
              TextSpan(text: '; Time Share: $timeSharePercentString%)'),
            ]
          ),
          const Spacer(),
        ],
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/dataclasses/activity_type_summary.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/components/charts/axis_bounds.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/color_gradient.dart';
import 'package:wellbeing/components/charts/axis_ticks.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:wellbeing/components/reusable/color_gradient_from_settings.dart';


class DurationWellbeingScatterChart extends ConsumerWidget {
  const DurationWellbeingScatterChart({
    super.key,
    required this.summaryList,
    required this.types,
    required this.xAxisBounds,
    required this.yAxisBounds
  });
  
  final List<ActivityTypeSummary> summaryList;
  final ActivityTypeCollection types;
  final AxisBounds xAxisBounds;
  final AxisBounds yAxisBounds;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);
    final ColorGradient colorGradient = colorGradientFromAppSettings(appSettings);

    final List<ScatterSpot> points = summaryList.map(((e) => ScatterSpot(
      e.durationSum,
      e.wellbeingAverage,
      color: types.getColorByIdOrNull(e.id),
          radius: 10,
    ))).toList();

    final Set<int> selectedSpots = ref.watch(timeScatterSelectedSpotsProvider);


    return ScatterChart(
        ScatterChartData(
          scatterSpots: points,
          minX: xAxisBounds.lowerWithPadding,
          maxX: xAxisBounds.higherWithPadding,
          minY: yAxisBounds.lowerWithPadding,
          maxY: yAxisBounds.higherWithPadding,
          titlesData: FlTitlesData(
            leftTitles: AxisTitles(
              axisNameWidget: const Text("Wellbeing"),
            ),
            bottomTitles: AxisTitles(
              axisNameWidget: const Text("Duration (in Minutes)")
            ),
            rightTitles: WellbeingAxis(colorGradient),
            topTitles: DurationAxis(xAxisBounds.lowerWithPadding, xAxisBounds.higherWithPadding)
          ),
          
          showingTooltipIndicators: selectedSpots.toList(),
          scatterTouchData: ScatterTouchData(
            enabled: true,
            handleBuiltInTouches: false,
            mouseCursorResolver:
                (FlTouchEvent touchEvent, ScatterTouchResponse? response) {
              return response == null || response.touchedSpot == null
                  ? MouseCursor.defer
                  : SystemMouseCursors.click;
            },
            touchTooltipData: ScatterTouchTooltipData(
              tooltipBgColor: Colors.black,
              getTooltipItems: (ScatterSpot touchedBarSpot) {
                ActivityTypeSummary? summary = getActivityTypeFromDurationAndWellbeing(
                  summaryList,
                  touchedBarSpot.x,
                  touchedBarSpot.y
                );
                final String label = types
                  .getNameByIdOrReturnDefault(summary?.id ?? '');

                return ScatterTooltipItem(
                  label,
                  textStyle: TextStyle(
                    height: 1.2,
                    color: Colors.grey[100],
                    fontStyle: FontStyle.italic,
                  ),
                  bottomMargin: 10
                );
              },
            ),
            touchCallback: (FlTouchEvent event, ScatterTouchResponse? touchResponse) {
              if (touchResponse?.touchedSpot == null) {
                return;
              }
              if (event is FlTapUpEvent) {
                final int spotIndex = touchResponse!.touchedSpot!.spotIndex;
                if (selectedSpots.contains(spotIndex)) {
                  selectedSpots.remove(spotIndex);
                } else {
                  selectedSpots.add(spotIndex);
                }
                ref.read(timeScatterSelectedSpotsProvider.state).state = {...selectedSpots};
              }
            },
          ),
        ),
      );
  }
}

ActivityTypeSummary? getActivityTypeFromDurationAndWellbeing(
  List<ActivityTypeSummary> summaryList,
  double duration,
  double wellbeing
) {
  for (ActivityTypeSummary summary in summaryList) {
    if (summary.durationSum == duration && summary.wellbeingAverage == wellbeing) {
      return summary;
    }
  }

  return null;
}


import 'package:flutter/material.dart';

class NoDataForChartInfo extends StatelessWidget {
  const NoDataForChartInfo({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Text(
        'No data points',
        style: Theme.of(context).textTheme.headline6,
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/dataclasses/color_gradient.dart';
import 'package:wellbeing/components/charts/axis_bounds.dart';
import 'package:wellbeing/components/charts/axis_ticks.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:wellbeing/components/reusable/color_gradient_from_settings.dart';


class TypeDurationWellbeingScatterChart extends ConsumerWidget {
  const TypeDurationWellbeingScatterChart({
    super.key,
    required this.entryList,
    required this.xAxisBounds,
    required this.yAxisBounds
  });
  
  final List<ActivityEntry> entryList;
  final AxisBounds xAxisBounds;
  final AxisBounds yAxisBounds;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);
    final ColorGradient colorGradient = colorGradientFromAppSettings(appSettings);

    final List<ScatterSpot> points = entryList.map(((e) => ScatterSpot(
      e.durationInMinutes.toDouble(),
      e.wellbeingScore,
      color: colorGradient.getColorAtPercentOpaque(e.wellbeingScore/100)
    ))).toList();

    final Set<int> selectedSpots = ref.watch(timeScatterSelectedSpotsProvider);


    return ScatterChart(
        ScatterChartData(
          scatterSpots: points,
          minX: xAxisBounds.lowerWithPadding,
          maxX: xAxisBounds.higherWithPadding,
          minY: yAxisBounds.lowerWithPadding,
          maxY: yAxisBounds.higherWithPadding,
          titlesData: FlTitlesData(
            leftTitles: AxisTitles(
              axisNameWidget: const Text("Wellbeing"),
            ),
            bottomTitles: AxisTitles(
              axisNameWidget: const Text("Duration (in Minutes)")
            ),
            rightTitles: WellbeingAxis(colorGradient),
            topTitles: DurationAxis(xAxisBounds.lowerWithPadding, xAxisBounds.higherWithPadding)
          ),
          showingTooltipIndicators: selectedSpots.toList(),
          scatterTouchData: ScatterTouchData(
            enabled: true,
            handleBuiltInTouches: false,
            mouseCursorResolver:
                (FlTouchEvent touchEvent, ScatterTouchResponse? response) {
              return response == null || response.touchedSpot == null
                  ? MouseCursor.defer
                  : SystemMouseCursors.click;
            },
            touchCallback: (FlTouchEvent event, ScatterTouchResponse? touchResponse) {
              if (touchResponse?.touchedSpot == null) {
                return;
              }
              if (event is FlTapUpEvent) {
                final int spotIndex = touchResponse!.touchedSpot!.spotIndex;
                if (selectedSpots.contains(spotIndex)) {
                  selectedSpots.remove(spotIndex);
                } else {
                  selectedSpots.add(spotIndex);
                }
                ref.read(timeScatterSelectedSpotsProvider.state).state = {...selectedSpots};
              }
            },
          ),
        ),
      );
  }
}



import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';


class ActivityTypeSelector extends ConsumerWidget {
  const ActivityTypeSelector({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {    
    final String? activityTypeSelectedId = ref.watch(activityTypeSelectedIdProvider);
    final ActivityTypeCollection activityTypes = ref.watch(activityTypeCollectionProvider);
    final Set<String> hiddenTypes = ref.watch(hiddenActivityTypesProvider);
    final Iterable<ActivityType> activityTypesVisible = activityTypes.values.where((e) => !hiddenTypes.contains(e.id));
    final Set<String> existingIds = activityTypesVisible.map((e) => e.id).toSet();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (activityTypeSelectedId == null || !existingIds.contains(activityTypeSelectedId)) {
        if (activityTypes.isEmpty) return;

        ref.read(activityTypeSelectedIdProvider.state).state = activityTypesVisible.first.id;
      }

      if (hiddenTypes.contains(activityTypeSelectedId)) {
        ref.read(activityTypeSelectedIdProvider.state).state = activityTypesVisible.first.id;
      }

    });

    if ( 
      !existingIds.contains(activityTypeSelectedId) ||
      activityTypeSelectedId == null ||
      activityTypesVisible.isEmpty ||
      hiddenTypes.contains(activityTypeSelectedId)
    ) {
      return Container();
    }

    return DropdownButton(
      value: activityTypeSelectedId,
      items: activityTypesVisible
        .map((e) => DropdownMenuItem(
          value: e.id,
          child: Row(
            children: [
              Icon(e.icon, color: e.color,),
              const SizedBox(width: 10,),
              Text(e.name),
            ]
          ),
        ))
        .toList(),
      onChanged: (value) {
        if (value is! String) return;
        ref.read(activityTypeSelectedIdProvider.state).state = value;
      }
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';


class DateFilterInput extends Column {
  DateFilterInput({super.key}) : super(
    children: const [
      SizedBox(height: 20,),
      DateSpanText(),
      SizedBox(height: 10,),
      DateFilterRow(),
      SizedBox(height: 20,),
    ]
  );
}


class DateSpanText extends ConsumerWidget {
  const DateSpanText({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final DateTimeRange? dateRange = ref.watch(dateRangeFilterProvider);

    final String displayString = dateRangeToString(dateRange);


    return Row(
      mainAxisSize: MainAxisSize.max,
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const Icon(Icons.calendar_month),
        const SizedBox(width: 5),
        Text(displayString),
      ],
    );
  }
}

String dateRangeToString(DateTimeRange? dateRange) {
  if (dateRange == null) {
    return "All Time";
  }

  final DateFormat formatter = DateFormat.yMd();

  if (dateRange.start == dateRange.end) {
    return formatter.format(dateRange.start);
  }

  return '${formatter.format(dateRange.start)} - ${formatter.format(dateRange.end)}';
}


class DateFilterRow extends ConsumerWidget {
  const DateFilterRow({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final DateFormat formatter = DateFormat.yMd();
    final DateTimeRange? dateRangeFromSelector = ref.read(dateRangeSelectorProvider);

    final String dateRangeButtonText = dateRangeFromSelector == null
      ? "Select Date Range"
      : "âœŽ ${formatter.format(dateRangeFromSelector.start)} - ${formatter.format(dateRangeFromSelector.end)}";


    List<DateRangeButtonFeature> buttonFeatures = [
      const DateRangeButtonFeature(text: "All Time", onPressed: setDateRangeNull),
      const DateRangeButtonFeature(text: "Today", onPressed: setDateRangeToday),
      const DateRangeButtonFeature(text: "Week", onPressed: setDateRangeToWeek),
      const DateRangeButtonFeature(text: "Month", onPressed: setDateRangeToMonth),
      DateRangeButtonFeature(text: dateRangeButtonText, onPressed: setDateRangeToRange),
    ];

    const VerticalDivider verticalDivider = VerticalDivider();

    List<Widget> buttonsWithSpace = [];

    for (int i = 0; i < buttonFeatures.length; i++) {
      buttonsWithSpace.add(SetDateRangeButton(
        keyIndex: i,
        onPressed: buttonFeatures[i].onPressed,
        label: buttonFeatures[i].text,
      ));
      buttonsWithSpace.add(verticalDivider);
    }

    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Wrap(children: buttonsWithSpace),
    );
  }
}

class DateRangeButtonFeature {
  final void Function(int, Reader, BuildContext) onPressed;
  final String text;

  const DateRangeButtonFeature({
    required this.onPressed,
    required this.text,
  });
}

class SetDateRangeButton extends ConsumerWidget {
  const SetDateRangeButton({super.key, required this.label, required this.keyIndex, required this.onPressed});

  final String label;
  final int keyIndex;
  final void Function(int, Reader, BuildContext) onPressed;


  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final int indexSelected = ref.watch(dateRangeButtonSelectedIndexProvider);
    final bool isSelected = keyIndex == indexSelected;

    return ElevatedButton(
      onPressed: () {
        onPressed(keyIndex, ref.read, context);
        ref.read(dateRangeButtonSelectedIndexProvider.state).state = keyIndex;
      },
      style: ElevatedButton.styleFrom(
        backgroundColor: isSelected ?
          Theme.of(context).colorScheme.primary :
          Colors.grey,
      ),
      child: Text(label)
    );
  }
}

void setDateRangeToday(int index, Reader stateReader, BuildContext context) {
  final DateTime now = DateTime.now();
  final DateTime todayStart = DateTime(now.year, now.month, now.day);

  stateReader(dateRangeFilterProvider.state).state = DateTimeRange(
    start: todayStart,
    end: todayStart
  );
}

void setDateRangeToWeek(int index, Reader stateReader, BuildContext context) {
  final DateTime now = DateTime.now();
  final DateTime todayStart = DateTime(now.year, now.month, now.day);
  final DateTime oneWeekBack = todayStart.subtract(const Duration(days: 6));

  stateReader(dateRangeFilterProvider.state).state = DateTimeRange(
    start: oneWeekBack,
    end: todayStart
  );
}

void setDateRangeToMonth(int index, Reader stateReader, BuildContext context) {
  final DateTime now = DateTime.now();
  final DateTime todayStart = DateTime(now.year, now.month, now.day);
  final DateTime oneWeekBack = todayStart.subtract(const Duration(days: 30));

  stateReader(dateRangeFilterProvider.state).state = DateTimeRange(
    start: oneWeekBack,
    end: todayStart
  );
}

void setDateRangeNull(int index, Reader stateReader, BuildContext context) {
  stateReader(dateRangeFilterProvider.state).state = null;
}


void setDateRangeToRange(int index, Reader stateReader, BuildContext context) async {
  final DateTimeRange? currentDateRange = stateReader(dateRangeSelectorProvider);
  final DateTimeRange dateRangeForSelection = stateReader(dateRangeForSelectionBounds);


  final DateTimeRange? dateRange = await showDateRangePicker(
    context: context,
    firstDate: dateRangeForSelection.start,
    lastDate: dateRangeForSelection.end,
    initialDateRange: currentDateRange
  );

  if (dateRange == null) return;

  stateReader(dateRangeSelectorProvider.state).state = dateRange;
  stateReader(dateRangeFilterProvider.state).state = dateRange;
}



import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/dataclasses/icon_list.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/components/reusable/custom_color_picker.dart';
import 'package:wellbeing/components/reusable/set_input.dart';


class ActivityCreationOrChange extends StatelessWidget {
  const ActivityCreationOrChange({
    super.key,
    required this.startingActivityTypeName,
    required this.doAddEntry
  });

  final String startingActivityTypeName;
  final bool doAddEntry;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(child: NewActivitySettingsContent(
        startText: startingActivityTypeName,
        doAddEntry: doAddEntry,
      )),
    );
  }
}

class NewActivitySettingsContent extends ConsumerWidget {
  NewActivitySettingsContent({
    super.key,
    required this.startText,
    required this.doAddEntry
  }) {
    nameTextController = TextEditingController(
      text: startText
    );
  }

  final String startText;
  final bool doAddEntry;

  late final TextEditingController nameTextController;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final IconData selectedIcon = ref.watch(iconProvider);
    final Color selectedColor = ref.watch(colorProvider);

    return Column(mainAxisAlignment: MainAxisAlignment.center, children: [
      TextField(
        controller: nameTextController,
        onChanged: (value) => ref.read(activityTypeNameInputProvider.state).state = value,
      ),
      SetInput(
        label: 'Icon',
        input: IconButton(
          icon: Icon(selectedIcon, color: selectedColor,),
          onPressed: () => showDialog(
              context: context,
              builder: (context) => IconPicker(context),
          )
        )
      ),
      SetInput(
        label: 'Color',
        input: ElevatedButton(
          style: ElevatedButton.styleFrom(backgroundColor: selectedColor),
          onPressed: () => showDialog(
            context: context,
            builder: (context) => CustomColorPicker(
              context: context,
              startColor: selectedColor,
              setColor: (Color color) => ref.read(colorProvider.state).state = color
            )
          ),
          child: const SizedBox(),
        )
      ),
      ButtonRow(doAddEntry: doAddEntry,)
    ],);
  }
}



class ButtonRow extends StatelessWidget {
  const ButtonRow({required this.doAddEntry, super.key});

  final bool doAddEntry;

  @override
  Widget build(BuildContext context) {
    return Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
        const PopButton(),
        OkayButton(doAddEntry: doAddEntry,)
      ]
    );
  }
}

class OkayButton extends ConsumerWidget {
  const OkayButton({required this.doAddEntry, super.key});

  final bool doAddEntry;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ElevatedButton(
      onPressed: () {
        final ActivityTypeCollection activityTypeCollection = ref.read(activityTypeCollectionProvider);

        final String? activityTypeId = ref.read(activityTypeIdProvider);

        if (activityTypeId == null) return;

        final String activityTypeName = ref.read(activityTypeNameInputProvider);
        final Set<String> existingNamesLower = activityTypeCollection
          .getExistingNames()
          .map((e) => e.toLowerCase())
          .toSet();
        final bool nameExists = existingNamesLower.contains(activityTypeName.toLowerCase());
        final bool currentNameExistisDueToEditing = activityTypeName.toLowerCase() == activityTypeCollection.getNameByIdOrReturnDefault(activityTypeId).toLowerCase();
        final bool nameExistsAndNotEditing = nameExists && !currentNameExistisDueToEditing;

        if (nameExistsAndNotEditing || activityTypeName.isEmpty) {
          const SnackBar snackBar = SnackBar(
            content: Text("Activity Type Name already exists or is empty. Please choose new Name."),
          );
          ScaffoldMessenger.of(context).showSnackBar(snackBar);

          return;
        }

        activityTypeCollection[activityTypeId] = ActivityType(
          id: activityTypeId,
          name: activityTypeName,
          color: ref.read(colorProvider),
          icon: ref.read(iconProvider),
        );

        final newActivityTypeCollection = ActivityTypeCollection({...activityTypeCollection.delegate});
        newActivityTypeCollection.saveToSharedPreferencesAndFirebaseWithId(ref.read);
        ref.read(activityTypeCollectionProvider.state).state = newActivityTypeCollection;
        
        if (doAddEntry) {
          addActivityEntry(ref.read);
        }
        Navigator.of(context).popUntil((route) => route.isFirst);
      },
      child: const Text("Okay")
    );
  }
}

class PopButton extends StatelessWidget {
  const PopButton({super.key});

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () => Navigator.of(context).pop(),
      child: const Text("Back")
    );
  }
}




class IconPicker extends AlertDialog {
  IconPicker(BuildContext context, {super.key}) : super(
    title: const Text('Pick an Icon'),
    content: Container(
      width: 320,
      height: 400,
      alignment: Alignment.center,
      child: IconGridView.builder()
    ),
    actions: [
      ElevatedButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Close'))
    ],
  );
}


class IconGridView extends GridView {
  IconGridView.builder({super.key }) : super.builder(
    gridDelegate: const SliverGridDelegateWithMaxCrossAxisExtent(
      maxCrossAxisExtent: 60,
      childAspectRatio: 1 / 1,
      crossAxisSpacing: 10,
      mainAxisSpacing: 10
    ),
    itemCount: iconList.length,
    itemBuilder: (_, index) => IconItem(index: index)
  );
}


class IconItem extends ConsumerWidget {
  
  const IconItem({super.key, required this.index});

  final int index;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final Color selectedColor = ref.watch(colorProvider);

    return Container(
      key: ValueKey(iconList[index].codePoint),
      padding: const EdgeInsets.all(10),
      child: Center(
        child: IconButton(
          color: selectedColor,
          iconSize: 30,
          icon: Icon(
            iconList[index],
          ),
          onPressed: () {
            ref.read(iconProvider.state).state = iconList[index];
            Navigator.of(context).pop();
          },
        ),
      ),
    );
  }
}
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:slide_to_act/slide_to_act.dart';
import 'package:wellbeing/components/activity_logging/activity_date_and_duration.dart';
import 'package:wellbeing/components/reusable/rich_text_adaptive.dart';
import 'package:wellbeing/components/reusable/wellbeing_selection.dart';


class ActivityEntryHistory extends ConsumerWidget {
  const ActivityEntryHistory({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<ActivityEntry> activityEntries = ref.watch(activityEntriesProvider);
    final ActivityTypeCollection activityTypes = ref.watch(activityTypeCollectionProvider);

    if (activityEntries.isEmpty) {
      return const Center(
        child: Text("No activity entries yet"),
      );
    }

    final List<Widget> activityEntryWidgets  = [];
    for (int i = activityEntries.length-1; i >= 0; i--) {
      activityEntryWidgets.add(ActivityEntryProfile(
        entries: activityEntries,
        types: activityTypes,
        index: i
      ));
      activityEntryWidgets.add(const Divider());
    }

    return SingleChildScrollView(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: activityEntryWidgets
      ),
    );
  }
}



class ActivityEntryProfile extends ConsumerWidget {
  ActivityEntryProfile({
    super.key,
    required this.entries,
    required this.types,
    required this.index,
  });

  final List<ActivityEntry> entries;
  final ActivityTypeCollection types;
  final int index;

  late BuildContext buildContext;
  late Reader stateReader;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    buildContext = context;
    stateReader = ref.read;

    final ActivityEntry entry = entries[index];
    final ActivityType type = types.getByIdOrReturnDefault(entry.activityTypeId);

    final double entryDescriptionWidth = MediaQuery.of(context).size.width * 0.6;

    return Padding(
      padding: const EdgeInsets.fromLTRB(10, 10, 10, 0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          SizedBox(
            width: entryDescriptionWidth,
            child: Row(
              children: [
                Icon(type.icon, color: type.color,),
                const SizedBox(width: 10,),
                EntryDescriptionWithClickable(
                  entry: entry,
                  type: type,
                  typeFunction: openActivityTypeChangeDigalog,
                  dateFunction: openDateChangeDialog,
                  durationFunction: openDurationChangeDialog,
                  wellbeingFunction: openWellbeingChangeDialog,
                ),
              ],
            ),
          ),
          const SizedBox(width: 10,),
          DeleteActivityTypeButton(
            entry: entry,
            type: type,
            removeEntryFunction: () {
              entries.removeAt(index);
              saveEntriesToSharedPreferencesAndFirebaseWithId(entries, stateReader);
              ref.read(activityEntriesProvider.state).state = [...entries];
              updateFavorites(ref.read);
            }
          ),
        ]
      ),
    );
  }

  
  void openActivityTypeChangeDigalog() {
    List<ActivityType> activityTypesAsList = types.values.toList();

    showDialog(
      context: buildContext,
      builder: (context) => AlertDialog(
        actions: [
          ElevatedButton(
            onPressed: Navigator.of(context).pop,
            child: const Text("Cancel"),
          ),
        ],
        content: SizedBox(
          height: 400,
          width: 400,
          child: ListView.separated(
            padding: const EdgeInsets.all(8),
            itemCount: activityTypesAsList.length,
            itemBuilder: (context, itemIndex) {
              return GestureDetector(
                onTap: () {
                  final String newTypeId = activityTypesAsList[itemIndex].id;
                  entries[index].activityTypeId = newTypeId;
                  saveEntriesToSharedPreferencesAndFirebaseWithId(entries, stateReader);
                  stateReader(activityEntriesProvider.state).state = [...entries];
                  Navigator.of(context).pop();
                },
                child: Container(
                  height: 50,
                  color: Theme.of(context).primaryColor,
                  child: Center(
                    child: Text(activityTypesAsList[itemIndex].name)
                  )
                )
              );
            },
            separatorBuilder: (context, index) => const Divider()
          ),
      ))
    );
  }

  void openDateChangeDialog() {
    showDialog(
      context: buildContext,
      builder: (context) => AlertDialog(
        actions: [Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween ,
          children: [
            ElevatedButton(
              onPressed: Navigator.of(context).pop,
              child: const Text("Cancel"),
            ),
            ElevatedButton(
              onPressed: () {
                final DateTime newDateTime = stateReader(selectedDateProvider);
                entries[index].date = newDateTime;
                saveEntriesToSharedPreferencesAndFirebaseWithId(entries, stateReader);
                stateReader(activityEntriesProvider.state).state = [...entries];
                Navigator.of(context).pop();
              },
              child: const Text("Ok"),
            ),
          ]
      )],
        content: const SizedBox(
          height: 100,
          width: 200,
          child: DateButton(),
        ),
      ),
    );
  }

  void openDurationChangeDialog() {
    stateReader(selectedDurationProvider.state).state = entries[index].durationInMinutes;

    showDialog(
      context: buildContext,
      builder: (context) => AlertDialog(
        actions: [Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween ,
          children: [
            ElevatedButton(
              onPressed: Navigator.of(context).pop,
              child: const Text("Cancel"),
            ),
            ElevatedButton(
              onPressed: () {
                final int newDuration = stateReader(selectedDurationProvider);
                entries[index].durationInMinutes = newDuration;
                saveEntriesToSharedPreferencesAndFirebaseWithId(entries, stateReader);
                stateReader(activityEntriesProvider.state).state = [...entries];
                Navigator.of(context).pop();
              },
              child: const Text("Ok"),
            ),
          ]
      )],
        content: const SizedBox(
          height: 100,
          width: 200,
          child: DurationButton(),
        ),
      ),
    );
  }
  
  void openWellbeingChangeDialog() {
    stateReader(wellbeingScoreProvider.state).state = middleWellbeingScore;

    final Size screenSize = MediaQuery.of(buildContext).size;

    final double containerWidth = screenSize.width * 0.7;
    final double containerHeight = screenSize.height * 0.5;

    final double smileySize = screenSize.width * 0.4;

    showDialog(
      context: buildContext,
      builder: (context) => AlertDialog(
        actions: [Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween ,
          children: [
            ElevatedButton(
              onPressed: Navigator.of(context).pop,
              child: const Text("Cancel"),
            ),
            ElevatedButton(
              onPressed: () {
                final double newWellbeing = stateReader(wellbeingScoreProvider);
                entries[index].wellbeingScore = newWellbeing;
                saveEntriesToSharedPreferencesAndFirebaseWithId(entries, stateReader);
                stateReader(activityEntriesProvider.state).state = [...entries];
                Navigator.of(context).pop();
              },
              child: const Text("Ok"),
            ),
          ]
      )],
        content: SizedBox(
          height: containerHeight,
          width: containerWidth,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              WellbeingSelection(smileySize: smileySize,)
            ]
          ),
        ),
      ),
    );
  }
}

class EntryDescriptionWithClickable extends StatelessWidget {
  const EntryDescriptionWithClickable({
    super.key,
    required this.entry,
    required this.type,
    required this.typeFunction,
    required this.dateFunction,
    required this.durationFunction,
    required this.wellbeingFunction,
  });


  final ActivityType type;
  final ActivityEntry entry;
  final VoidCallback typeFunction;
  final VoidCallback dateFunction;
  final VoidCallback durationFunction;
  final VoidCallback wellbeingFunction;

  @override
  Widget build(BuildContext context) {
    final DateFormat formatter = DateFormat.yMd();
    final String dateString = formatter.format(entry.date);

    final String wellbeingString = entry.wellbeingScore.round().toString();

    TextStyle standardColorTextStyle = TextStyle(
      fontSize: 20,
      color: Theme.of(context).colorScheme.onBackground,
    );

    TextStyle openOnTapTextStyle = TextStyle(
      color: Theme.of(context).colorScheme.secondary,
      fontWeight: FontWeight.bold,
      fontSize: 20
    );

    return Flexible(
      child: RichTextAdaptive(
        children: [
          TextSpan(
            text: type.name,
            style: openOnTapTextStyle,
            recognizer: TapGestureRecognizer()
              ..onTap = typeFunction
          ),
          TextSpan(
            text: "\non ",
            style: standardColorTextStyle
          ),
          TextSpan(
            text: dateString,
            style: openOnTapTextStyle,
            recognizer: TapGestureRecognizer()
              ..onTap = dateFunction
          ),
          TextSpan(
            text: "\nfor ",
            style: standardColorTextStyle
          ),  
          TextSpan(
            text: "${entry.durationInMinutes} minutes.",
            style: openOnTapTextStyle,
            recognizer: TapGestureRecognizer()
              ..onTap = durationFunction
          ),
          TextSpan(
            text: "\nWellbeing Score: ",
            style: standardColorTextStyle
          ),
          TextSpan(
            text: wellbeingString,
            style: openOnTapTextStyle,
            recognizer: TapGestureRecognizer()
              ..onTap = wellbeingFunction
          )
        ]
      ),
    );
  }
}


class DeleteActivityTypeButton extends ConsumerWidget {
  const DeleteActivityTypeButton({
    super.key,
    required this.entry,
    required this.type,
    required this.removeEntryFunction,
  });

  final ActivityEntry entry;
  final ActivityType type;
  final VoidCallback removeEntryFunction;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ElevatedButton(
      onPressed: () => openDeleteDialog(context, ref.read),
      child: const Text("Delete")
    );
  }

  void openDeleteDialog(BuildContext context, Reader stateReader) {
    final DateFormat formatter = DateFormat.yMd();
    final String dateString = formatter.format(entry.date);

    final String questionText = 
      "Delete the activity entry of Type ${type.name}?\n"
      "On $dateString for ${entry.durationInMinutes} minutes";

    showDialog(
      context: context,
      builder: (BuildContext context) => AlertDialog(
        actions: [
          ElevatedButton(
            onPressed: Navigator.of(context).pop,
            child: const Text("Cancel"),
          ),
        ],
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(questionText),
            const SizedBox(height: 10,),
            SlideAction(
              onSubmit: () {
                removeEntryFunction();
                Navigator.of(context).pop();
              },
              animationDuration: const Duration(milliseconds: 500),
              innerColor: Colors.red,
              outerColor: Theme.of(context).splashColor,
              text: "Delete"
            ),
          ],
        ),
      )
    );
  }
}



import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:slide_to_act/slide_to_act.dart';
import 'package:wellbeing/components/pages/activity_creation_or_change.dart';


class ActivityTypesList extends ConsumerWidget {
  const ActivityTypesList({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final ActivityTypeCollection activityTypeCollection = ref.watch(activityTypeCollectionProvider);

    if (activityTypeCollection.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text("No activity types have been created yet."),
            const Text("Create one by pressing the button below."),
            const SizedBox(height: 20,),
            AddNewActivityTypeButton(types: activityTypeCollection,),
          ],
        ),
      );
    }

    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        HideAllButton(typeIds: activityTypeCollection.keys,),
        ...activityTypeCollection.values.map(
          (e) => ActivityTypeProfile(e)
        ),
        AddNewActivityTypeButton(types: activityTypeCollection,)
      ]
    );
  }
}


class AddNewActivityTypeButton extends ConsumerWidget {
  const AddNewActivityTypeButton({required this.types, super.key});

  final ActivityTypeCollection types;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ElevatedButton(
          onPressed: () {
            Set<String> existingIds = types.getExistingIds();
            final String newId = createUniqueId(existingIds);
            ref.read(activityTypeIdProvider.state).state = newId;
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => const ActivityCreationOrChange(
                  startingActivityTypeName: '',
                  doAddEntry: false,
                )
              )
            );
          },
          child: const Text('Add Activity Type'),
        );
  }
}

class HideAllButton extends ConsumerWidget {
  const HideAllButton({super.key, required this.typeIds});

  final Iterable<String> typeIds;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    Set<String> hiddenActivityTypes = ref.watch(hiddenActivityTypesProvider);
    final bool allHidden = !typeIds.any((e) => !hiddenActivityTypes.contains(e));

    return Row(
      children: [
        IconButton(
          icon: Icon(allHidden ? Icons.visibility_off : Icons.visibility),
          onPressed: () {
            if (allHidden) {
              hiddenActivityTypes = {};
            } else {
              hiddenActivityTypes.addAll(typeIds);
            }
            saveHiddenActivityTypesToSharedPreferencesAndFirebaseWithId(hiddenActivityTypes, ref.read);
            ref.read(hiddenActivityTypesProvider.state).state = {...hiddenActivityTypes};
          },
        ),
        Expanded(child: Container())
      ],
    );
  }
}


class ActivityTypeProfile extends ConsumerWidget {
  const ActivityTypeProfile(this.activityType, {super.key});

  final ActivityType activityType;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final Set<String> hiddenActivityTypes = ref.watch(hiddenActivityTypesProvider);
    final bool isHidden = hiddenActivityTypes.contains(activityType.id);


    return Row(
      children: [
        IconButton(
          icon: Icon(isHidden ? Icons.visibility_off : Icons.visibility),
          onPressed: () {
            if (isHidden) {
              hiddenActivityTypes.remove(activityType.id);
            } else {
              hiddenActivityTypes.add(activityType.id);
            }
            saveHiddenActivityTypesToSharedPreferencesAndFirebaseWithId(hiddenActivityTypes, ref.read);
            ref.read(hiddenActivityTypesProvider.state).state = {...hiddenActivityTypes};
          },
        ),
        const SizedBox(width: 10,),
        Icon(activityType.icon, color: activityType.color,),
        const SizedBox(width: 10,),
        Text(activityType.name),
        Expanded(child: Container(),),
        EditActivityTypeButton(type: activityType),
        const SizedBox(width: 10,),
        DeleteActivityTypeButton(type: activityType),
        const SizedBox(width: 20,)
      ]
    );
  }
}


class DeleteActivityTypeButton extends ConsumerWidget {
  const DeleteActivityTypeButton({required this.type, super.key});

  final ActivityType type;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ElevatedButton(
      onPressed: () => openDeleteDialog(context, ref.read),
      child: const Text("Delete")
    );
  }

  void openDeleteDialog(BuildContext context, Reader stateReader) {
    showDialog(
      context: context,
      builder: (BuildContext context) => AlertDialog(
        actions: [
          ElevatedButton(
            onPressed: Navigator.of(context).pop,
            child: const Text("Cancel"),
          ),
        ],
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text("Delete ${type.name}?\nThis will also delete all entries of this type."),
            const SizedBox(height: 10,),
            SlideAction(
              onSubmit: () => onSlideComplete(context, stateReader),
              animationDuration: const Duration(milliseconds: 500),
              innerColor: Colors.red,
              outerColor: Theme.of(context).splashColor,
              text: "Delete"
            ),
          ],
        ),
      )
    );
  }

  void onSlideComplete(BuildContext context, Reader stateReader) {
    final ActivityTypeCollection activityTypeCollection = stateReader(activityTypeCollectionProvider);
    activityTypeCollection.remove(type.id);
    updateFavorites(stateReader);
    // Todo Update with firebase
    activityTypeCollection.saveToSharedPreferencesAndFirebaseWithId(stateReader);
    stateReader(activityTypeCollectionProvider.state).state = ActivityTypeCollection({...activityTypeCollection});

    final List<ActivityEntry> activityEntries = stateReader(activityEntriesProvider);
    final List<ActivityEntry> activitiesFiltered = activityEntries.where((e) => !(e.activityTypeId == type.id)).toList();
    saveEntriesToSharedPreferencesAndFirebaseWithId(activitiesFiltered, stateReader);
    stateReader(activityEntriesProvider.state).state = activitiesFiltered;

    final Set<String> hiddenActivityTypes = stateReader(hiddenActivityTypesProvider);
    hiddenActivityTypes.remove(type.id);
    saveHiddenActivityTypesToSharedPreferencesAndFirebaseWithId(hiddenActivityTypes, stateReader);
    stateReader(hiddenActivityTypesProvider.state).state = {...hiddenActivityTypes};

    stateReader(activityTypeSelectedIdProvider.state).state = null;

    updateFavorites(stateReader);

    Navigator.of(context).pop();
  }
}


class EditActivityTypeButton extends ConsumerWidget {
  const EditActivityTypeButton({required this.type, super.key});

  final ActivityType type;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return IconButton(
      icon: const Icon(Icons.edit),
      onPressed: () {
        ref.read(iconProvider.state).state = type.icon;
        ref.read(colorProvider.state).state = type.color;
        ref.read(activityTypeIdProvider.state).state = type.id;
        ref.read(activityTypeNameInputProvider.state).state = type.name;

        Navigator.of(context).push(
        MaterialPageRoute(builder: (context) => ActivityCreationOrChange(
          startingActivityTypeName: type.name,
          doAddEntry: false,
        )),
      );
      },
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/charts/duration_wellbeing_pie_chart_with_indicators.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:wellbeing/dataclasses/activity_type_summary.dart';
import 'package:wellbeing/components/dashboard_elements/date_filter_input.dart';
import 'package:wellbeing/components/charts/axis_bounds.dart';
import 'package:wellbeing/components/charts/duration_wellbeing_scatter_chart.dart';
import 'package:wellbeing/components/charts/no_data_for_chart_info.dart';
import 'package:wellbeing/components/charts/duration_wellbeing_bar_chart.dart';
import 'dart:math';



class DashboardActivityTime extends StatelessWidget {
  const DashboardActivityTime({super.key});

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        DateFilterInput(),
        const DropdownAndInfoButton(),
        const ChartDisplay(),
        const SizedBox(height: 40),
      ],
    );
  }
}

class DropdownAndInfoButton extends StatelessWidget {
  const DropdownAndInfoButton({super.key});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: const [
          SizedBox(width: 25,),
          ChartTypeDropdown(),
          InfoButton(),
        ],
      ),
    );
  }
}

class InfoButton extends ConsumerWidget {
  const InfoButton({super.key});

  static List<String> infoTexts = [
    'This chart shows the duration in minutes (x-axis) and the average wellbeing scores (y-axis) of each activity in the selected time period.\n'
    'The color of the dots corresponds to the category color. You can display the category name by clicking or pressing on the dot.\n\n'
    'This chart allows you to see how much time you spend to activities that bring you wellbeing and how much on activities that don\'t.',

    'The upper chart displays the average wellbeing score for each activity in the selected time period.\n'
    'The lower chart displays the duration of each activity (in minutes) in the selected time period.\n'
    'The color of the bars corresponds to the category color. You can display the values by clicking or pressing on the bar.Bars are sorted by average wellbeing score.\n\n'
    'This chart allows you to see how much time you spend to activities that bring you wellbeing and how much on activities that don\'t.',

    'The slice size represents the time share an activity had in the selected time period. The color of the slices corresponds to the average wellbeing score in that time period\n'
    'Slices are sorted by the average wellbeing score in the selected time period. The indicators at the botton show the numerical information\n\n'
    'This chart allows you to see how much time you spend to activities that bring you wellbeing and how much on activities that don\'t.',
  ];
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final int chartType = ref.watch(chartTypeIndexActivityProvider);

    return IconButton(
      icon: const Icon(Icons.info_outline),
      onPressed: () => showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Chart Info'),
          content: Text(infoTexts[chartType]),
          actions: [
            TextButton(
              onPressed: Navigator.of(context).pop,
              child: const Text('OK'),
            ),
          ],
        ),
      ),
    );
  }
}


class ChartDisplay extends ConsumerWidget {
  const ChartDisplay({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final int chartTypeIndex = ref.watch(chartTypeIndexActivityProvider);
    final ActivityTypeCollection activityTypes = ref.watch(activityTypeCollectionProvider);
    final List<ActivityEntry> entries = ref.watch(activityEntriesProvider);
    final DateTimeRange? dateFilter = ref.watch(dateRangeFilterProvider);
    final Set<String> hiddenActivityTypes = ref.watch(hiddenActivityTypesProvider);
    final Map<String, ActivityTypeSummary> activityTypeSummaries = summarizedByActivityType(entries, dateFilter, hiddenActivityTypes);
    final List<ActivityTypeSummary> activityTypeSummaryList = activityTypeSummaries.values.toList();

    if (activityTypeSummaryList.isEmpty) {
      return const NoDataForChartInfo();
    }


    activityTypeSummaryList.sort((a, b) => (a.wellbeingAverage > b.wellbeingAverage) ? -1 : 1);


    final double minDurationInMin = getDurationInMinMinimumFromTypeSummaryList(activityTypeSummaryList);
    final double maxDurationInMin = getDurationInMinMaximumFromTypeSummaryList(activityTypeSummaryList);

    final AxisBounds durationBounds = AxisBounds(minDurationInMin, maxDurationInMin);
    final AxisBounds wellbeingBounds = AxisBounds(minWellbeingScore, maxWellbeingScore);

    
    List<Widget> charts = [
      DurationWellbeingScatterChart(
        summaryList: activityTypeSummaryList,
        types: activityTypes,
        xAxisBounds: durationBounds,
        yAxisBounds: wellbeingBounds
      ),
      BarChartColumn(
        summaryList: activityTypeSummaryList,
        types: activityTypes,
        durationBounds: durationBounds,
        wellbeingBounds: wellbeingBounds,
      ),
      DurationWellbeingPieChartWithIndicators(
        summaryList: activityTypeSummaryList,
        types: activityTypes
      ),
    ];


    return Flexible(
      fit: FlexFit.tight,
      child: charts[chartTypeIndex],
    );
  }
}





class ChartTypeDropdown extends ConsumerWidget {
  const ChartTypeDropdown({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final int chartTypeIndex = ref.watch(chartTypeIndexActivityProvider);

    return DropdownButton(
      value: chartTypeIndex,
      items: const [
        DropdownMenuItem(
          value: 0,
          child: Icon(Icons.scatter_plot),
        ),
        DropdownMenuItem(
          value: 1,
          child: Icon(Icons.bar_chart),
        ),
        DropdownMenuItem(
          value: 2,
          child: Icon(Icons.pie_chart),
        ),
      ],
      onChanged: (value) {
        if (value is! int) return;
        ref.read(chartTypeIndexActivityProvider.state).state = value;
      }
    );
  }
}


double getDurationInMinMinimumFromTypeSummaryList(List<ActivityTypeSummary> summaryList) {
  return summaryList
    .map(((e) => e.durationSum))
    .reduce(min)
    .toDouble();
}

double getDurationInMinMaximumFromTypeSummaryList(List<ActivityTypeSummary> summaryList) {
  return summaryList
    .map(((e) => e.durationSum))
    .reduce(max)
    .toDouble();
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/dashboard_elements/date_filter_input.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/charts/no_data_for_chart_info.dart';
import 'package:wellbeing/components/charts/axis_bounds.dart';
import 'package:wellbeing/components/dashboard_elements/activity_type_selector.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:wellbeing/components/charts/type_duration_wellbeing_scatter_chart.dart';
import 'dart:math';


class DashboardTime extends ConsumerWidget {
  const DashboardTime({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      children: [
        DateFilterInput(),
        const ActivityTypeSelector(),
        const ChartDisplay(),
      ],
    );
  }
}

class ChartDisplay extends ConsumerWidget {
  const ChartDisplay({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<ActivityEntry> entries = ref.watch(activityEntriesProvider);
    final DateTimeRange? dateFilter = ref.watch(dateRangeFilterProvider);
    final String? activityTypeSelectedId = ref.watch(activityTypeSelectedIdProvider);
    final Set<String> hiddenTypes = ref.watch(hiddenActivityTypesProvider);


    if (activityTypeSelectedId == null || hiddenTypes.contains(activityTypeSelectedId)) {
      return const NoDataForChartInfo();
    }

    final Iterable<ActivityEntry> entriesFilteredByDate = dateFilter == null
      ? entries
      : entries
        .where((e) => !(
          e.date.isBefore(dateFilter.start) ||
          e.date.isAfter(dateFilter.end))    
    );
    
    final List<ActivityEntry> entriesFiltered = entriesFilteredByDate
      .where((e) => e.activityTypeId == activityTypeSelectedId)
      .toList();

    if (entriesFiltered.isEmpty) {
      return const NoDataForChartInfo();
    }

    final double minDurationInMin = getDurationInMinMinimumFromEntryList(entriesFiltered);
    final double maxDurationInMin = getDurationInMinMaximumFromEntryList(entriesFiltered);

    final AxisBounds durationBounds = AxisBounds(minDurationInMin, maxDurationInMin);
    final AxisBounds wellbeingBounds = AxisBounds(minWellbeingScore, maxWellbeingScore);

    return Flexible(
      child: AspectRatio(
        aspectRatio: 1,
        child: TypeDurationWellbeingScatterChart(
          entryList: entriesFiltered,
          xAxisBounds: durationBounds,
          yAxisBounds: wellbeingBounds
        )
      ),
    );
  }
}



double getDurationInMinMinimumFromEntryList(List<ActivityEntry> entryList) {
  return entryList
    .map(((e) => e.durationInMinutes))
    .reduce(min)
    .toDouble();
}

double getDurationInMinMaximumFromEntryList(List<ActivityEntry> summaryList) {
  return summaryList
    .map(((e) => e.durationInMinutes))
    .reduce(max)
    .toDouble();
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/activity_logging/activity_date_and_duration.dart';
import 'package:wellbeing/components/activity_logging/activity_type_picker_with_input.dart';
import 'package:wellbeing/components/pages/activity_creation_or_change.dart';
import 'package:wellbeing/components/reusable/wellbeing_selection.dart';

class Logger extends ConsumerWidget {
  const Logger({super.key});

  @override 
  Widget build(BuildContext context, WidgetRef ref) {
    WidgetsBinding.instance.addPostFrameCallback((_) => resetIDandScore(ref.read));

    return const Scaffold(
      body: Center(child: LoggerContent()),
      resizeToAvoidBottomInset: false,
    );
  }
}


class LoggerContent extends StatelessWidget {
  const LoggerContent({super.key});

  @override
  Widget build(BuildContext context) {
    return Column(children: [
      Expanded(child: Container()),
      ActivityTypePickerWithInput(),
      const SizedBox(height: 20,),
      const ActivityDateAndDuration(),
      const SizedBox(height: 20,),
      const WellbeingSelection(),
      const SizedBox(height: 20,),
      const ButtonRow(),
    ],);
  }
}

void resetIDandScore(Reader stateReader) {
    stateReader(activityTypeIdProvider.state).state = null;
    stateReader(wellbeingScoreProvider.state).state = middleWellbeingScore;
}



class ButtonRow extends StatelessWidget {
  const ButtonRow({super.key});

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: Padding(
        padding: const EdgeInsets.fromLTRB(10, 0, 10, 0),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          mainAxisSize: MainAxisSize.max,
          children: const [
            CancelButton(),
            OkayButton()
          ],
        ),
      ),
    );
  }
}


class CancelButton extends StatelessWidget {
  const CancelButton({super.key});

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: Navigator.of(context).pop,
      child: const Text("Cancel"),
    );
  }
}

class OkayButton extends ConsumerWidget { 
  const OkayButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ElevatedButton(
      onPressed: () {
        final String? activityTypeId = ref.read(activityTypeIdProvider);

        if (activityTypeId == null) {
          const SnackBar snackBar = SnackBar(
            content: Text("Select Acitivity Type or add a new one (with the + Button)"),
          );
          ScaffoldMessenger.of(context).showSnackBar(snackBar);

          return;
        }

        final ActivityTypeCollection activityTypes = ref.read(activityTypeCollectionProvider);
        final bool activityExists = activityTypes
          .getExistingIds()
          .contains(activityTypeId);

        if (!activityExists) {
          final String activityTypeName = ref.read(activityTypeNameInputProvider);
          Navigator.of(context).push(
            MaterialPageRoute(builder: (context) => ActivityCreationOrChange(
              startingActivityTypeName: activityTypeName,
              doAddEntry: true,
            )),
          );
        } else {
          addActivityEntry(ref.read);
          Navigator.of(context).popUntil((route) => route.isFirst);
        }
      },
      child: const Text('Okay')
    );
  }
}





import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/pages/dashboard_types.dart';
import 'package:wellbeing/components/pages/theory_and_how_to.dart';
import 'package:wellbeing/components/pages/logger.dart';
import 'package:curved_navigation_bar/curved_navigation_bar.dart';
import 'package:wellbeing/components/pages/settings_page.dart';
import 'package:wellbeing/components/pages/activity_entry_history.dart';
import 'package:wellbeing/components/pages/dashboard_activity_time.dart';
import 'package:wellbeing/components/pages/activity_types_list.dart';

class Root extends ConsumerWidget {
  const Root({super.key});

  final List<Widget> pages = const [
    DashboardActivityTime(),
    DashboardTime(),
    ActivityEntryHistory(),
    ActivityTypesList(),
    TheoryAndHowTo(),
    SettingPage()
  ];

  @override 
  Widget build(BuildContext context, WidgetRef ref) {
    final int pageIndex = ref.watch(pageIndexProvider);


    return Scaffold(
      body: SafeArea(child: pages.elementAt(pageIndex)),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed: () => Navigator.of(context).push(
          MaterialPageRoute(builder: (context) => const Logger()),
        ),
      ),
      bottomNavigationBar: CurvedNavigationBar(
        color: Theme.of(context).colorScheme.secondary,
        backgroundColor: Theme.of(context).canvasColor,
        animationDuration: const Duration(milliseconds: 150),
        items: const [
          BottomNavigationBarIcon(iconDashboardSummaries),  // dashboard: time spent
          BottomNavigationBarIcon(iconDashboardTypes),  // dashboard: activity inspection
          BottomNavigationBarIcon(iconEntryHistory),  // activity history
          BottomNavigationBarIcon(iconTypeList),  // activity type list
          BottomNavigationBarIcon(iconTheoryHowTo),  // Info Page
          BottomNavigationBarIcon(iconSettings),  // settings
        ],
        onTap: (index) {
          ref.read(pageIndexProvider.state).state = index;
        },
      ),
    );
  }
}


class BottomNavigationBarIcon extends StatelessWidget {
  const BottomNavigationBarIcon(this.icon, {super.key});

  final IconData icon;

  @override
  Widget build(BuildContext context) {
    return Icon(
      icon,
      size: 30,
      color: Theme.of(context).colorScheme.onSecondary,
    );
  }
}

final StateProvider<int> pageIndexProvider = StateProvider((ref) => 0);


import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:wellbeing/components/reusable/custom_color_picker.dart';
import 'package:wellbeing/components/reusable/set_input.dart';
import 'package:wellbeing/components/user_button/user_button.dart';


class SettingPage extends ConsumerWidget {
  const SettingPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      children: const [
        UserButtonRow(),
        Spacer(),
        Settings(),
        Spacer(),
      ],
    );
  }
}

class Settings extends ConsumerWidget {
  const Settings({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: const [
        SetDarkModeInput(),
        SizedBox(height: 15,),
        SetShowFavoritesInput(),
        SizedBox(height: 15,),
        SetShowSmileyEyeBrowsInput(),
        SizedBox(height: 15,),
        SetSmileyGradientColorNegativeInput(),
        SizedBox(height: 15,),
        SetSmileyGradientColorPositiveInput()
      ],
    );
  }
}


class SetDarkModeInput extends ConsumerWidget {
  const SetDarkModeInput({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);

    return SetInput(
        label: "Dark Mode",
        input: Switch(
          value: appSettings.darkMode,
          onChanged: ((value) {
            appSettings.updateSetDarkMode(value, ref.read);
            appSettings.saveToSharedPreferencesAndFirebaseWithId(ref.read);
          }),
        )
      );
  }
}


class SetShowFavoritesInput extends ConsumerWidget {
  const SetShowFavoritesInput({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);

    return SetInput(
      label: "Show Favorite Activities",
      input: Switch(
        value: appSettings.showFavoriteActivities,
        onChanged: ((value) {
          appSettings.updateShowFavoriteActivities(value, ref.read);
          appSettings.saveToSharedPreferencesAndFirebaseWithId(ref.read);
        }),
      )
    );
  }
}


class SetShowSmileyEyeBrowsInput extends ConsumerWidget {
  const SetShowSmileyEyeBrowsInput({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);

    return SetInput(
      label: "Show Smiley Eye Brows",
      input: Switch(
        value: appSettings.showSmileyEyeBrows,
        onChanged: ((value) {
          appSettings.updateShowSmileyEyeBrows(value, ref.read);
          appSettings.saveToSharedPreferencesAndFirebaseWithId(ref.read);
        }),
      )
    );
  }
}


class SetSmileyGradientColorNegativeInput extends ConsumerWidget {
  const SetSmileyGradientColorNegativeInput({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);

    return SetInput(
      label: "Negative Smiley Color",
      input: ElevatedButton(
        onPressed: () => showDialog(
          context: context,
          builder: (context) => CustomColorPicker(
            context: context,
            startColor: appSettings.smileyGradientColorNegative,
            setColor: (Color color) {
              appSettings.updateSmileyGradientColorNegative(color, ref.read);
              appSettings.saveToSharedPreferencesAndFirebaseWithId(ref.read);
            }
          ),
        ),
        style: ElevatedButton.styleFrom(
          backgroundColor: appSettings.smileyGradientColorNegative,
        ),
        child: const Text("Set"),
      )
    );
  }
}

class SetSmileyGradientColorPositiveInput extends ConsumerWidget {
  const SetSmileyGradientColorPositiveInput({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);

    return SetInput(
      label: "Positive Smiley Color",
      input: ElevatedButton(
        onPressed: () => showDialog(
          context: context,
          builder: (context) => CustomColorPicker(
            context: context,
            startColor: appSettings.smileyGradientColorPositive,
            setColor: (Color color) {  // TODO colors are not changing even though new values are passed to firebase
              appSettings.updateSmileyGradientColorPositive(color, ref.read);
              appSettings.saveToSharedPreferencesAndFirebaseWithId(ref.read);
            }
          ),
        ),
        style: ElevatedButton.styleFrom(
          backgroundColor: appSettings.smileyGradientColorPositive,
        ),
        child: const Text("Set"),
      )
    );
  }
}

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/reusable/rich_text_adaptive.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';


class TheoryAndHowTo extends ConsumerWidget {
  const TheoryAndHowTo({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AppSettings appSettings = ref.watch(appSettingsProvider);

    final bool isDark = appSettings.darkMode;
    final String pathToClusterImage = isDark
      ? 'assets/images/cluster_dark.png'
      : 'assets/images/cluster_light.png';

    return SingleChildScrollView(
      child: Center(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const HeadingLevelOne('How to use this app'),
              const HeadingLevelTwo('Adding new Entries'),
              TextAddEntry(),
              const SizedBox(height: 20,),
              const HeadingLevelTwo('Adding new Activity Types'),
              TextAddType(),
              const SizedBox(height: 50,),
              const HeadingLevelOne('Theory'),
              const HeadingLevelTwo('Why to use this app'),
              ReasonToUseText(),
              const HeadingLevelTwo('Problem ist nicht VerfÃ¼gbarkeit sondern Konzentration'),
              const HeadingLevelTwo('Unterschiede Happiness Wellbeing'),
              Image.asset(pathToClusterImage),
            ]
          ),
        ),
      ),
    );
  }
}




class TextAddType extends RichTextAdaptive {
  TextAddType({super.key}) : super(
    children: [
      const TextSpan(text: 'To add a new activity type, tap on the Activity Types List Tab (',),
      const WidgetSpan(child: Icon(iconTypeList)),
      const TextSpan(text: ' ) and press the Add Activity Type or enter a new type into the textfield when logging a new entry via the floating action button (',),
      const WidgetSpan(child: Icon(Icons.add_circle)),
      const TextSpan(text: ' ) and press the plus button (',),
      const WidgetSpan(child: Icon(Icons.add)),
      const TextSpan(text: ') on the right site of the textfield. Color and Icon can be set afterwards.',),
    ]
  );
}

class TextAddEntry extends RichTextAdaptive {
  TextAddEntry({super.key}) : super(
    children: [
      const TextSpan(text: 'To add a new entry, tap on the floating action button (',),
      const WidgetSpan(child: Icon(Icons.add_circle)),
      const TextSpan(text: ' )',)
    ]
  );
}

class ReasonToUseText extends Column {
  ReasonToUseText({super.key}) : super(
    children: const [
      Text(
        "In todays fast pace times, it is sometimes hard to keep track of how you spend your time. Too often, this leads to us spending our time mainly on things, that we don't enjoy or that result in discontentment later on (even if we are free to do whatever we want)."
      ),
      Text(
        "Even further, things that are supposed to be fun, like watching a movie or playing a game, can become a burden if we do them too often. This is especially true for things that are supposed to be fun, but that we do too often. This is the case for many people with video games, for example."
      )
    ]
  );
}


class HeadingLevelOne extends StatelessWidget {
  const HeadingLevelOne(this.text, {super.key});

  final String text;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(0, 0, 0, 20) ,
      child: Center(
        child: Text(
          text,
          style: const HeadingStyleLevelOne()
        )
      ),
    );
  }
}

class HeadingLevelTwo extends StatelessWidget {
  const HeadingLevelTwo(this.text, {super.key});

  final String text;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(0, 0, 0, 10) ,
      child: Text(
        text,
        style: const HeadingStyleLevelTwo()
      )
    );
  }
}

class HeadingStyleLevelOne extends TextStyle {
  const HeadingStyleLevelOne() : super(
    fontSize: 40,
    fontWeight: FontWeight.bold
  );
}

class HeadingStyleLevelTwo extends TextStyle {
  const HeadingStyleLevelTwo() : super(
    fontSize: 25,
    fontStyle: FontStyle.italic
  );
}import 'package:flutter/material.dart';
import 'dart:math';
import 'package:wellbeing/dataclasses/color_gradient.dart';

class SmileyAdaptive extends StatelessWidget {
  const SmileyAdaptive({
    required this.currentValue,
    required this.minValue,
    required this.maxValue,
    required this.size,
    required this.colorGradient,
    required this.hasEyebrows,
    super.key
  });

  final double currentValue;
  final double minValue;
  final double maxValue;
  final double size;
  final ColorGradient colorGradient;
  final bool hasEyebrows;

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      foregroundPainter: SmileyAdaptivePainter(
        currentValue: currentValue,
        minValue: minValue,
        maxValue: maxValue,
        paintAreaSize: size,
        colorGradient: colorGradient,
        hasEyebrows: hasEyebrows
      ),
      child: SizedBox(width: size, height: size),
    );
  }
}



class SmileyAdaptivePainter extends CustomPainter {
  SmileyAdaptivePainter({
    required this.paintAreaSize,
    required this.hasEyebrows,
    required double currentValue,
    required double minValue,
    required double maxValue,
    required ColorGradient colorGradient
  }) {
    double valueInPercent = getPercentWithinRange(minValue, maxValue, currentValue);
    colorCalculated = colorGradient.getColorAtPercentOpaque(valueInPercent);

    valueScaled_0_100 = valueInPercent*100;
    final double valueReversedAfter50 = reverseAt50(valueScaled_0_100);

    mouthAndEyebrowGeometry = 50-valueReversedAfter50;
  }

  final double paintAreaSize;
  final bool hasEyebrows;
  late final Color colorCalculated;
  late final double valueScaled_0_100;
  late final double mouthAndEyebrowGeometry;


  @override
  void paint(Canvas canvas, Size size) {
    drawHead(canvas);
    drawEyes(canvas);
    drawMouth(canvas);
    if (hasEyebrows) {
      drawEyebrows(canvas);
    }
  }

  void drawEyebrows(Canvas canvas) {
        final Paint eyebrowPaint = Paint()  
      ..strokeWidth = paintAreaSize/40
      ..color = colorCalculated
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;
    
    final double eyeBrowYPositionBase = (0.17*paintAreaSize);
    double eyeBrowYPositionTarget = eyeBrowYPositionBase - mouthAndEyebrowGeometry * (paintAreaSize/450);
    final double eyeBrowArcRadius = 100 * (paintAreaSize / 200);

    final leftEyebrowPath = Path()
      ..moveTo(0.21*paintAreaSize, eyeBrowYPositionBase)
      ..arcToPoint(
          Offset(0.44*paintAreaSize, eyeBrowYPositionTarget),
          radius: Radius.circular(eyeBrowArcRadius),
          clockwise: true
      );

    final rightEyebrowPath = Path()
      ..moveTo(0.56*paintAreaSize, eyeBrowYPositionTarget)
      ..arcToPoint(
          Offset(0.79*paintAreaSize, eyeBrowYPositionBase),
          radius: Radius.circular(eyeBrowArcRadius),
          clockwise: true
      );


    canvas.drawPath(leftEyebrowPath, eyebrowPaint); 
    canvas.drawPath(rightEyebrowPath, eyebrowPaint);
  }

  void drawHead(Canvas canvas) {
    final Paint smileyPaint = Paint()
      ..style = PaintingStyle.stroke
      ..strokeWidth = paintAreaSize/20
      ..color = colorCalculated;

    Offset center = Offset(paintAreaSize/2, paintAreaSize/2);
    canvas.drawCircle(center, paintAreaSize/2, smileyPaint);
  }

  void drawEyes(Canvas canvas) {
    final Paint eyePaint = Paint()..color = colorCalculated;

    Offset leftEye = Offset(paintAreaSize/3, paintAreaSize/3);
    Offset rightEye = Offset(paintAreaSize-paintAreaSize/3, paintAreaSize/3);

    Rect leftEyeRect = Rect.fromCenter(center: leftEye, height: paintAreaSize/6.5, width: paintAreaSize/10.3);
    Rect rightEyeRect = Rect.fromCenter(center: rightEye, height: paintAreaSize/6.5, width: paintAreaSize/10.3);

    canvas.drawOval(leftEyeRect, eyePaint);
    canvas.drawOval(rightEyeRect, eyePaint);
  }

  void drawMouth(Canvas canvas) {
    final double xStart = 0.25*paintAreaSize;
    final double xEnd = 0.75*paintAreaSize;
    final double mouthWidth = xEnd - xStart;

    double currentRadius = calcCorrectRadius(mouthAndEyebrowGeometry, mouthWidth/2);

    final Paint mouthPaint = Paint()  
      ..strokeWidth = paintAreaSize/25
      ..color = colorCalculated
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final double yPosition = (paintAreaSize*0.78) - valueScaled_0_100 * (paintAreaSize/600);
    final bool reverseSmile = valueScaled_0_100 < 50;

    final Path mouthPath = Path()
      ..moveTo(xStart, yPosition)
      ..arcToPoint(
          Offset(xEnd, yPosition),
          radius: Radius.circular(currentRadius),
          clockwise: reverseSmile
      );
    canvas.drawPath(mouthPath, mouthPaint); 
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return false;
  }
}


double getPercentWithinRange(double minValue, double maxValue, double currentValue) {
  double range = maxValue-minValue;
  double absoluteState = currentValue-minValue;

  return absoluteState/range;
}


double calcCorrectRadius(double x, double l) {
  // Formula R = (1/2x) * (l^2+x^2)
  // where R = Radius
  // l length of half the mouth
  // x = flexion

  double normedX = x*l/50;

  if (normedX == 0) { // Formula does not work with 0
    normedX = 0.00000001;
  } 

  double leadingDivision = 1 / (2*normedX);
  num multiplyBy = pow(l, 2) + pow(normedX, 2);
  double radius = leadingDivision * multiplyBy;

  return radius;
}

double reverseAt50(double value_0to100) {
  final bool isBelow50 = value_0to100 < 50;
  final double translatedValue = !isBelow50
    ? 100 - value_0to100
    : value_0to100;
  return translatedValue;
}import 'package:wellbeing/dataclasses/color_gradient.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';

ColorGradient colorGradientFromAppSettings(AppSettings settings) {
  return ColorGradient.fromTwoColors(
    settings.smileyGradientColorNegative,
    settings.smileyGradientColorPositive,
  );
}import 'package:flutter/material.dart';
import 'package:flutter_colorpicker/flutter_colorpicker.dart';

class CustomColorPicker extends AlertDialog {
  CustomColorPicker({
    required this.context,
    required this.startColor,
    required this.setColor,
    super.key
  }): super(
    title: const Text('Pick a color!'),
    content: SingleChildScrollView(
      child: ColorPicker(
        pickerColor: startColor,
        onColorChanged: setColor,
      ),
    ),
    actions: <Widget>[
      ElevatedButton(
        child: const Text('Got it'),
        onPressed: () {
          Navigator.of(context).pop();
        },
      ),
    ]
  );

  final BuildContext context;
  final Color startColor;
  final void Function(Color) setColor;
}import 'package:flutter/material.dart';

class RichTextAdaptive extends StatelessWidget {
  const RichTextAdaptive({super.key, required this.children});

  final List<InlineSpan> children;

  @override
  Widget build(BuildContext context) {
    final TextStyle adaptiveFontColor = TextStyle(color: Theme.of(context).colorScheme.onSurface);

    return RichText(
      text: TextSpan(
        children: children.map((el) {
            if (el is TextSpan) {
              return TextSpan(
                text: el.text,
                style: el.style ?? adaptiveFontColor,
                recognizer: el.recognizer,
              );
            } else {
              return el;
            }
          }).toList()
      )
    );
  }
}import 'package:flutter/material.dart';

class SetInput extends StatelessWidget {
  const SetInput({required this.label, required this.input, super.key});

  final String label;
  final Widget input;

  @override
  Widget build(BuildContext context) {
    final double width = MediaQuery.of(context).size.width;
    final double tenPercentWidth = width * 0.1;

    return Padding(
      padding: 
      EdgeInsets.fromLTRB(tenPercentWidth, 0, tenPercentWidth, 0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text('$label: '),
          input
        ]
      ),
    );
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/color_gradient.dart';
import 'package:wellbeing/components/reusable/adaptive_smiley.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';

class WellbeingSelection extends ConsumerWidget {
  const WellbeingSelection({super.key, this.smileySize});

  final double? smileySize;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final double currentWellbeingScore = ref.watch(wellbeingScoreProvider);
    final AppSettings appSettings = ref.watch(appSettingsProvider);

    final Size screenSize = MediaQuery.of(context).size;
    final double smallerDimension = screenSize.width < screenSize.height
      ? screenSize.width
      : screenSize.height;

    return Column(children: [
      SmileyAdaptive(
        currentValue: currentWellbeingScore,
        minValue: minWellbeingScore,
        maxValue: maxWellbeingScore,
        size: smileySize != null
          ? smileySize!
          : smallerDimension * 0.5,
        hasEyebrows: appSettings.showSmileyEyeBrows,
        colorGradient: ColorGradient.fromTwoColors(
          appSettings.smileyGradientColorNegative,
          appSettings.smileyGradientColorPositive
        ),
      ),
      const SizedBox(height: 10,),
      Slider(
        value: currentWellbeingScore,
        min: minWellbeingScore,
        max: maxWellbeingScore,
        divisions: (maxWellbeingScore-minWellbeingScore).toInt(),
        onChanged: (value) => ref.read(wellbeingScoreProvider.state).state = value,
        label: currentWellbeingScore.toString(),
      )
    ],);
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/user_button/user_button_adaptive_error_widgets.dart';
import 'package:email_validator/email_validator.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:wellbeing/components/user_button/user_button_providers.dart';
import 'package:wellbeing/components/user_button/login_result.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/user_button/reset_password_dialog.dart';




class LoginWrapper {
  LoginWrapper({
    required this.context,
    required this.stateReader,
  }) {
    stateReader(emailProvider.state).state = null;
    emailController = TextEditingController();
    passwordController = TextEditingController();
  }

  final BuildContext context;
  final Reader stateReader;
  late final TextEditingController emailController;
  late final TextEditingController passwordController;
  late FirebaseAuth firebaseAuth;

  void openLogin() {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        actions: [
          LoginButtonRow( 
            loginButtonPress: loginButtonPress,
            closeButtonPress: closeButtonPress,
          )
        ],
        content: LoginInput(
          emailController: emailController,
          passwordController: passwordController,
        ),
      ),
    );
  }

  void loginButtonPress() async {
    firebaseAuth = FirebaseAuth.instance;

    final String email = emailController.text;
    final bool emailValid = EmailValidator.validate(email);

    stateReader(emailValidProvider.state).state = emailValid;

    if (!emailValid) {
      return;
    }

    try {
      await firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: passwordController.text
      );
      stateReader(loginResultProvider.state).state = LoginResult.success;
    } on FirebaseAuthException catch (e) {
      if (e.code == 'user-not-found') {
        stateReader(loginResultProvider.state).state = LoginResult.userNotFound;
      } else if (e.code == 'wrong-password') {
        stateReader(loginResultProvider.state).state = LoginResult.wrongPassword;
      }
    }
  }

  void closeButtonPress() {
    Navigator.of(context).pop();
  }
}


class LoginButtonRow extends ConsumerWidget {
  const LoginButtonRow({
    super.key,
    required this.loginButtonPress,
    required this.closeButtonPress
  });

  final VoidCallback loginButtonPress;
  final VoidCallback closeButtonPress;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final bool userIsLoggedIn = ref.watch(userIsLoggedInProvider);

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween ,
      children: [
        ElevatedButton(
          onPressed: closeButtonPress,
          child: const Text("Close"),
        ),
        userIsLoggedIn
          ? Container()
          : ElevatedButton(
            onPressed: loginButtonPress,
            child: const Text("Login"),
          ),
      ]
    );
  }
}




class LoginInput extends ConsumerWidget {
  const LoginInput({
    super.key,
    required this.emailController,
    required this.passwordController,
  });

  final TextEditingController emailController;
  final TextEditingController passwordController;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final LoginResult loginResult = ref.watch(loginResultProvider);
    final bool emailValid = ref.watch(emailValidProvider);
    final bool userIsLoggedIn = ref.watch(userIsLoggedInProvider);

    if (userIsLoggedIn) {
      return const Text("You are logged in");
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        ErrorsafeTextField(
          controller: emailController,
          labelText: "Email",
          autofocus: true,
          showError: !emailValid || loginResult == LoginResult.userNotFound,
          onChanged: (value) => ref.read(emailProvider.state).state = value,
        ),
        OptionalErrorFeedback(
          showError: !emailValid,
          errorText: "Not a valid Email",
        ),
        OptionalErrorFeedback(
          showError: loginResult == LoginResult.userNotFound,
          errorText: "User not found",
        ),
        ErrorsafeTextField(
          controller: passwordController,
          labelText: "Password",
          showError: loginResult == LoginResult.wrongPassword,
          isPassword: true,
        ),
        OptionalErrorFeedback(
          showError: loginResult == LoginResult.wrongPassword,
          errorText: "Wrong password",
        ),
        const SizedBox(height: 15,),
        const PasswordResetButton()
      ],
    );
  }
}





import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/user_button/login_dialog.dart';
import 'package:wellbeing/components/user_button/sign_up_dialog.dart';

class LoginOrSingUpWrapper {
  const LoginOrSingUpWrapper({
    required this.context,
    required this.stateReader,
  });

  final BuildContext context;
  final Reader stateReader;

  void openLoginOrSignUp() {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        actions: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween ,
            children: [
              ElevatedButton(
                onPressed: Navigator.of(context).pop,
                child: const Text("Cancel"),
              ),
              ElevatedButton(
                onPressed: loginButtonPress,
                child: const Text("Login"),
              ),
              ElevatedButton(
                onPressed: signUpButtonPress,
                child: const Text("Sign up"),
              ),
            ]
          )
        ],
        content: const Text("Login or Sign Up?"),
      ),
    );
  }

  void loginButtonPress() {
    Navigator.of(context).pop();
    LoginWrapper(
      context: context,
      stateReader: stateReader,
    ).openLogin();
  }

  void signUpButtonPress() {
    Navigator.of(context).pop();
    SignUpWrapper(
      context: context,
      stateReader: stateReader,
    ).openSignUp();
  }
}
enum LoginResult {
  success,
  userNotFound,
  wrongPassword,
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';


class LogoutWrapper {
  const LogoutWrapper({
    required this.context,
    required this.stateReader,
  });

  final BuildContext context;
  final Reader stateReader;

  void openLogout() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        actions: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween ,
            children: [
              ElevatedButton(
                onPressed: Navigator.of(context).pop,
                child: const Text("Cancel"),
              ),
              ElevatedButton(
                onPressed: logoutButtonPress,
                child: const Text("Logout"),
              ),
            ]
          )
        ],
        content: const Text("Are you sure you want to logout?"),
      ),
    );
  }

  void logoutButtonPress() {
    FirebaseAuth.instance.signOut();
    stateReader(activityEntriesProvider.state).state = [];
    stateReader(activityTypeCollectionProvider.state).state = ActivityTypeCollection({});
    stateReader(appSettingsProvider.state).state = AppSettings.defaultSettings();
    stateReader(hiddenActivityTypesProvider.state).state = {};
    stateReader(favoriteActivityTypesProvider.state).state = {};
    Navigator.of(context).pop();
  }
}

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/user_button/user_button_providers.dart';
import 'package:email_validator/email_validator.dart';
import 'package:firebase_auth/firebase_auth.dart';

final StateProvider<bool> emailSentProvider = StateProvider((ref) => false);

class PasswordResetButton extends ConsumerWidget {
  const PasswordResetButton({super.key});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    WidgetsBinding.instance.addPersistentFrameCallback((_) {
    });

    final String? email = ref.watch(emailProvider);

    return TextButton(
      onPressed: () => checkMailAndOpenDialog(context, email),
      child: const Text("Forgot password?"),
    );
  }

  void checkMailAndOpenDialog(BuildContext context, String? email) {
    if (email == null || !EmailValidator.validate(email)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Not a valid Email"),
        ),
      );
      return;
    } 
    openPasswordResetDialog(context, email);
  }

  void openPasswordResetDialog(BuildContext context, String email) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        content: Text("Do you want to reset your password for $email?"),
        actions: [
          PasswordResetButtonRow(email)
        ],
      ),
    );
  }
}

class PasswordResetButtonRow extends ConsumerWidget {
  const PasswordResetButtonRow(this.email, {super.key});

  final String email;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final bool showYesButton = !ref.watch(emailSentProvider);

    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        ElevatedButton(
          onPressed: () {
            ref.read(emailSentProvider.state).state = false;
            Navigator.of(context).pop();
          },
          child: const Text("Close"),
        ),
        showYesButton
          ? ElevatedButton(
            onPressed: () => resetFirebasePassword(context, ref.read),
            child: const Text("Yes"),
          )
          : Container(),
      ],
    );
  }

  Future<void> resetFirebasePassword(BuildContext context, Reader stateReader) async {
    final FirebaseAuth firebaseAuth = FirebaseAuth.instance;

    try {
      await firebaseAuth.sendPasswordResetEmail(email: email); 
      stateReader(emailSentProvider.state).state = true;
    } on FirebaseAuthException catch (e) {
      if (e.code == 'user-not-found') {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text("User not found"),
          ),
        );
      } 
      return;
    }
  }
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/user_button/user_button_adaptive_error_widgets.dart';
import 'package:email_validator/email_validator.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:wellbeing/components/user_button/user_button_providers.dart';
import 'package:flutter_pw_validator/flutter_pw_validator.dart';


class SignUpWrapper {
  SignUpWrapper({
    required this.context,
    required this.stateReader,
  }) {
    emailController = TextEditingController();
    passwordController = TextEditingController();
    passwordConfirmController = TextEditingController();
  }

  final BuildContext context;
  final Reader stateReader;
  late final TextEditingController emailController;
  late final TextEditingController passwordController;
  late final TextEditingController passwordConfirmController;

  void openSignUp() {
    showDialog(
    context: context,
    builder: (dialogContext) => AlertDialog(
      actions: [
        SignUpButtonRow(
          okayButtonPress: okayButtonPress,
          cancelButtonPress: cancelButtonPress,
        )
      ],
      content: SignUpInput(
        emailController: emailController,
        passwordController: passwordController,
        passwordCheckController: passwordConfirmController,
      ),
    ),
  );
  }

  void okayButtonPress() {
    final String email = emailController.text;
    final bool emailValid = EmailValidator.validate(email);
    final String password = passwordController.text;
    final String passwordCheck = passwordConfirmController.text;
    final bool passwordValid = stateReader(passwordValidProvider);
    final bool passwordsMatching = (
      password.isNotEmpty &&
      password == passwordCheck
    );

    stateReader(emailValidProvider.state).state = emailValid;
    stateReader(passwordValidProvider.state).state = passwordValid;
    stateReader(passwordsMatchingProvider.state).state = passwordsMatching;

    if (!emailValid || !passwordValid || !passwordsMatching) {
      return;
    }
    
    final firebaseAuth = FirebaseAuth.instance;
    firebaseAuth.createUserWithEmailAndPassword(
      email: email,
      password: password
    );

    Navigator.of(context).pop();
  }

  void cancelButtonPress() {
    stateReader(emailValidProvider.state).state = true;
    stateReader(passwordValidProvider.state).state = true;

    Navigator.of(context).pop();
  }

}


class SignUpButtonRow extends StatelessWidget {
  const SignUpButtonRow({
    super.key,
    required this.okayButtonPress,
    required this.cancelButtonPress,
  });

  final VoidCallback okayButtonPress;
  final VoidCallback cancelButtonPress;

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween ,
      children: [
        ElevatedButton(
          onPressed: cancelButtonPress,
          child: const Text("Cancel"),
        ),
        ElevatedButton(
          onPressed: okayButtonPress,
          child: const Text("Ok"),
        ),
      ]
    );
  }

}


class SignUpInput extends ConsumerWidget {
  const SignUpInput({
    super.key,
    required this.emailController,
    required this.passwordController,
    required this.passwordCheckController,
  });

  final TextEditingController emailController;
  final TextEditingController passwordController;
  final TextEditingController passwordCheckController;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final bool emailValid = ref.watch(emailValidProvider);
    final bool passwordsMatching = ref.watch(passwordsMatchingProvider);

    return Column(
      mainAxisSize: MainAxisSize.min,
          children: [
            ErrorsafeTextField(
              controller: emailController,
              showError: !emailValid,
              labelText: "Email",
              autofocus: true,
            ),
            OptionalErrorFeedback(
              showError: !emailValid,
              errorText: "Invalid email",
            ),
            TextField(
              controller: passwordController,
              decoration: const InputDecoration(
                labelText: "Password",
              ),
              obscureText: true,
            ),
            FlutterPwValidator(
              controller: passwordController,
              minLength: PasswordRequirements.minLength,
              normalCharCount: PasswordRequirements.normalCharCount,
              uppercaseCharCount: PasswordRequirements.uppercaseCharCount,
              numericCharCount: PasswordRequirements.numericCharCount,
              specialCharCount: PasswordRequirements.specialCharCount,
              width: 400,
              height: 150,
              onSuccess: () => ref.read(passwordValidProvider.state).state = true,
              onFail: () => ref.read(passwordValidProvider.state).state = false,
            ),
            TextField(
              controller: passwordCheckController,
              decoration: InputDecoration(
                labelText: 'Password Confirmation',
                focusedBorder: conditionalErrorBorder(!passwordsMatching),
                enabledBorder: conditionalErrorBorder(!passwordsMatching),
              ),
              obscureText: true,
            ),
            OptionalErrorFeedback(
              showError: !passwordsMatching,
              errorText: "Passwords do not match",
            ),
          ],
        );
  }
}


class PasswordRequirements {
  static int minLength = 8;
  static int normalCharCount = 1;
  static int uppercaseCharCount = 1;
  static int numberCount = 1;
  static int specialCharCount = 1;
  static int numericCharCount = 1;
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/components/user_button/login_or_sign_up_dialog.dart';
import 'package:wellbeing/components/user_button/logout_dialog.dart';



class UserButtonRow extends StatelessWidget {
  const UserButtonRow({super.key});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(12),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: const [
          UserButton()
        ]
      ),
    );
  }
}


class UserButton extends ConsumerWidget {
  const UserButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {

    final LoginOrSingUpWrapper loginOrSingUpWrapper = LoginOrSingUpWrapper(
      context: context,
      stateReader: ref.read
    );

    final LogoutWrapper logoutWrapper = LogoutWrapper(
      context: context,
      stateReader: ref.read
    );

    final userIsLoggedIn = ref.watch(userIsLoggedInProvider);

    return IconButton(
      icon: Icon(
        Icons.person,
        color: userIsLoggedIn
          ? Theme.of(context).colorScheme.primary
          : null
      ),
      onPressed: userIsLoggedIn
        ? logoutWrapper.openLogout
        : loginOrSingUpWrapper.openLoginOrSignUp
    );
  }
}
import 'package:flutter/material.dart';

class ErrorsafeTextField extends StatelessWidget {
  const ErrorsafeTextField({
    super.key,
    required this.controller,
    required this.labelText,
    required this.showError,
    this.autofocus = false,
    this.onChanged,
    this.isPassword = false,
  });

  final bool showError;
  final String labelText;
  final TextEditingController controller;
  final bool autofocus;
  final void Function(String)? onChanged;
  final bool isPassword;

  @override
  Widget build(BuildContext context) {
    return TextField(
      controller: controller,
      decoration: InputDecoration(
        focusedBorder: conditionalErrorBorder(showError),
        enabledBorder: conditionalErrorBorder(showError),
        labelText: labelText,
      ),
      autofocus: autofocus,
      onChanged: onChanged,
      obscureText: isPassword,
    );
  }
}

class OptionalErrorFeedback extends StatelessWidget {
  const OptionalErrorFeedback({
    super.key,
    required this.showError,
    required this.errorText,
  }); 

  final bool showError;
  final String errorText;

  @override
  Widget build(BuildContext context) {
    return showError
      ? ErrorText(errorText)
      : Container();
  }
}


class ErrorUnderlineInputBorder extends UnderlineInputBorder {
  const ErrorUnderlineInputBorder({
    super.borderSide = const BorderSide(color: Colors.red),
  });
}

InputBorder? conditionalErrorBorder(show) => show
  ? const ErrorUnderlineInputBorder()
  : null;  


class ErrorText extends Text {
  const ErrorText(super.data, {
    super.key,
    super.style = const TextStyle(color: Colors.red),
  });
}
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/user_button/login_result.dart';

final StateProvider<String?> emailProvider = StateProvider((ref) => null);
final StateProvider<bool> emailValidProvider = StateProvider((ref) => true);
final StateProvider<bool> passwordValidProvider = StateProvider((ref) => true);
final StateProvider<bool> passwordsMatchingProvider = StateProvider((ref) => true);
final StateProvider<LoginResult> loginResultProvider = StateProvider((ref) => LoginResult.success);
import 'dart:convert';
import 'package:wellbeing/providers_and_settings/keys_for_save_and_load.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/providers_and_settings/firebase_helpers.dart';

class ActivityEntry {
  ActivityEntry({
    required this.activityTypeId,
    required this.durationInMinutes,
    required this.date,
    required this.wellbeingScore
  });

  ActivityEntry.fromMap(Map<String, dynamic> map) :
    activityTypeId = map['activityTypeId'],
    durationInMinutes = map['durationInMinutes'],
    date = DateTime.fromMillisecondsSinceEpoch(map['date']),
    wellbeingScore = map['wellbeingScore'] is int
      ? map['wellbeingScore'].toDouble()
      : map['wellbeingScore'];

  String activityTypeId;
  int durationInMinutes;
  DateTime date;
  double wellbeingScore;

  Map<String, dynamic> toMap() {
    return {
      'activityTypeId': activityTypeId,
      'durationInMinutes': durationInMinutes,
      'date': date.millisecondsSinceEpoch,
      'wellbeingScore': wellbeingScore
    };
  }

  String toJSONString() {
    return jsonEncode(toMap());
  }

  @override
  String toString() {
    return 'ActivityEntry{activityTypeId: $activityTypeId, durationInMinutes: $durationInMinutes, date: $date, wellbeingScore: $wellbeingScore}';
  }

  @override
  bool operator ==(Object other) {
    ActivityEntry otherEntry = other as ActivityEntry;
    return activityTypeId == otherEntry.activityTypeId &&
      durationInMinutes == otherEntry.durationInMinutes &&
      date == otherEntry.date &&
      wellbeingScore == otherEntry.wellbeingScore;
  }

  @override
  int get hashCode => activityTypeId.hashCode ^
    durationInMinutes.hashCode ^
    date.hashCode ^
    wellbeingScore.hashCode;
}

Future<void> saveEntriesToSharedPreferences(List<ActivityEntry> entries) async {
  final SharedPreferences prefs = await SharedPreferences.getInstance();

  final List<String> entriesAsJSON = entries.map((e) => e.toJSONString()).toList();
  prefs.setStringList(activityEntriesKey, entriesAsJSON);
}

void saveEntriesToFirebaseWithId(List<ActivityEntry> entries, Reader stateReader) async {
  final String? userId = stateReader(userIdFirebaseProvider);
    if (userId != null) {
      final List<String> entriesAsStringList = entries.map((e) => e.toJSONString()).toList();
      setValueToFirebase('$usersKey/$userId/$activityEntriesKey', entriesAsStringList);
  }
}

Future<void> saveEntriesToSharedPreferencesAndFirebaseWithId(List<ActivityEntry> entries, Reader stateReader) async {
  await saveEntriesToSharedPreferences(entries);
  saveEntriesToFirebaseWithId(entries, stateReader);
}


List<ActivityEntry> joinEntryLists(List<ActivityEntry> list1, List<ActivityEntry> list2) {
  final List<ActivityEntry> joinedList = [...list1];
  for (final ActivityEntry entry in list2) {
    if (!joinedList.contains(entry)) {
      joinedList.add(entry);
    }
  }

  return joinedList;
}import 'package:flutter/material.dart';
import 'package:uuid/uuid.dart';
import 'package:quiver/collection.dart';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:wellbeing/providers_and_settings/keys_for_save_and_load.dart';
import 'package:wellbeing/providers_and_settings/firebase_helpers.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';

class ActivityType {
  ActivityType({
    required this.id,
    required this.name,
    required this.color,
    this.icon = Icons.circle
  });

  final String id;
  String name;
  Color color;
  IconData icon;

  ActivityType.fromMap(Map<String, dynamic> map) :
    id = map['id'],
    name = map['name'],
    color = Color(map['color']),
    icon = IconData(map['icon'], fontFamily: 'MaterialIcons');

  @override
  String toString() {
    return 'ActivityType{id: $id, name: $name}';
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'color': color.value,
      'icon': icon.codePoint
    };
  }

  bool equals(ActivityType other) {
    return id == other.id &&
      name == other.name &&
      color == other.color &&
      icon == other.icon;
  }
}


String createUniqueId(Set<String> existingIds) {
  const Uuid uuid = Uuid();

  String newId = uuid.v1();

  while (existingIds.contains(newId)) {
    newId = uuid.v1();
  } 

  return newId;
}


class ActivityTypeCollection extends DelegatingMap<String, ActivityType> {
  ActivityTypeCollection(this.delegate);
  
  @override
  final Map<String, ActivityType> delegate;

  final ActivityType defaultReturn = ActivityType(
    name: "Fallback Type",
    color: Colors.black,
    id: "FallbackID",
    icon: Icons.circle
  );

  ActivityType getByIdOrReturnDefault(String id) {
    return delegate[id] ?? defaultReturn;
  }

  String? getNameByIdOrNull(String id) => delegate[id]?.name;
  String getNameByIdOrReturnDefault(String id) => getByIdOrReturnDefault(id).name;
  
  Color? getColorByIdOrNull(String id) => delegate[id]?.color;
  Color getColorByIdOrReturnDefault(String id) => getByIdOrReturnDefault(id).color;
  
  IconData? getIconByIdOrNull(String id) => delegate[id]?.icon;
  IconData? getIconByIdOrReturnDefault(String id) => getByIdOrReturnDefault(id).icon;

  Set<String> getExistingIds() => delegate.keys.toSet();
  Set<String> getExistingNames() => delegate.values.map((e) => e.name).toSet();


  bool nameDoesExist(String nameCaseInsensitive) {
    Set<String> existingNamesLower = getExistingNames()
      .map((e) => e.toLowerCase(),)
      .toSet();

    bool doesExist = existingNamesLower.contains(nameCaseInsensitive.toLowerCase());
    return doesExist;
  }

  String? getNameByNameOrNull(String nameCaseInsensitive) {
    bool doesExist = nameDoesExist(nameCaseInsensitive);
    if (doesExist) {
      return getByNameOrReturnDefault(nameCaseInsensitive).name;
    }

    return null;
  }

  
  ActivityType getByNameOrReturnDefault(String nameCaseInsensitive) {
    for (ActivityType e in delegate.values) {
      if (e.name.toLowerCase() == nameCaseInsensitive.toLowerCase()) {
        return e;
      }
    }

    return defaultReturn;
  }

  Map<String, dynamic> toMap() {
    return delegate.map((key, value) => MapEntry(key, value.toMap()));
  }

  String toJSONString() {
    return jsonEncode(toMap());
  }
  
  Future<void> saveToSharedPreferences() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    prefs.setString(activityTypesKey, toJSONString());
  }
  
  void saveToFirebaseWithId(stateReader) {
    final String? userId = stateReader(userIdFirebaseProvider);
      if (userId != null) {
        setValueToFirebase('$usersKey/$userId/$activityTypesKey', toMap());
    }
  }

  Future<void> saveToSharedPreferencesAndFirebaseWithId(stateReader) async {
    await saveToSharedPreferences();
    saveToFirebaseWithId(stateReader);
  }

  ActivityTypeCollection createAndReturnJoinedCollection(ActivityTypeCollection? other) {
    if (other == null) {
      return this;
    }

    Map<String, ActivityType> newMap = Map.from(delegate);
    newMap.addAll(other.delegate);
    return ActivityTypeCollection(newMap);
  }
}import 'package:flutter/material.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';

Map<String, ActivityTypeSummary> summarizedByActivityType(List<ActivityEntry> entries, DateTimeRange? dateRange, [Set<String>? activityTypesToExclude]) {
  Map<String, ActivityTypeSummary> summarizedMap = {};
  for (ActivityEntry entry in entries) {
    if (dateRange != null) {
      if (entry.date.isBefore(dateRange.start) || entry.date.isAfter(dateRange.end)) {
        continue;
      }
    }

    if (activityTypesToExclude != null) {
      if (activityTypesToExclude.contains(entry.activityTypeId)) {
        continue;
      }
    }

    if (!summarizedMap.keys.contains(entry.activityTypeId)) {
      summarizedMap[entry.activityTypeId] = ActivityTypeSummary.createNew(
        id: entry.activityTypeId,
        wellbeing: entry.wellbeingScore, durationInMinutes: entry.durationInMinutes
      );
    } else {
      summarizedMap[entry.activityTypeId]?.addValues(wellbeing: entry.wellbeingScore, durationInMinutes: entry.durationInMinutes);
    }
  }

  return summarizedMap;
}

class ActivityTypeSummary {
  ActivityTypeSummary({
    required this.id,
    required this.wellbeingValues,
    required this.durationInMinutesValues
  });

  ActivityTypeSummary.createNew({
    required this.id,
    required double wellbeing,
    required int durationInMinutes
  }) :
    wellbeingValues = [wellbeing],
    durationInMinutesValues = [durationInMinutes] {
      wellbeingAverage = wellbeing;
      durationSum = durationInMinutes.toDouble();
    }

  final String id;
  List<double> wellbeingValues;
  List<int> durationInMinutesValues;
  double durationSum = 0;
  double wellbeingAverage = 0;

  void addValues({
    required double wellbeing,
    required int durationInMinutes
  }) {
    wellbeingValues.add(wellbeing);
    durationInMinutesValues.add(durationInMinutes);

    wellbeingAverage = getWellbeingAverage();
    durationSum = getDurationSum();
  }

  int countValues() => wellbeingValues.length;

  double getWellbeingSum() => wellbeingValues.reduce((a, b) => a + b);

  double getWellbeingAverage() {
    final int count = countValues();
    final double sum = getWellbeingSum();
    return sum / count;
  }
  
  double getDurationSum() => durationInMinutesValues.reduce((a, b) => a + b).toDouble();

  double getDurationAverage() {
    final int count = countValues();
    final double sum = getDurationSum();
    return sum / count;
  }
}
import 'package:flutter/material.dart';

class RedToGreenColorGradient extends ColorGradient {
  RedToGreenColorGradient() : super.fromTwoColors(
    Colors.red.shade400,
    Colors.green.shade400
  );
}

class ColorGradient {
  ColorGradient({
    required this.redBounds,
    required this.greenBounds,
    required this.blueBounds
  });
  
  ColorGradient.fromTwoColors(Color startColor, Color endColor) {
    redBounds = ColorBounds(lowestRGB: startColor.red, highestRGB: endColor.red);
    greenBounds = ColorBounds(lowestRGB: startColor.green, highestRGB: endColor.green);
    blueBounds = ColorBounds(lowestRGB: startColor.blue, highestRGB: endColor.blue);
  }

  late final ColorBounds redBounds;
  late final ColorBounds greenBounds;
  late final ColorBounds blueBounds;

  Color getColorAtPercentWithAlpha(double percent, int alpha) {
    return Color.fromARGB(
      alpha,
      redBounds.getValueAtPercent(percent),
      greenBounds.getValueAtPercent(percent),
      blueBounds.getValueAtPercent(percent)
    );
  }

  Color getColorAtPercentOpaque(double percent) {
    return getColorAtPercentWithAlpha(percent, 255);
  }
}

class ColorBounds {
  const ColorBounds({this.lowestRGB = 0, this.highestRGB = 255});

  final int lowestRGB;
  final int highestRGB;

  int getValueAtPercent(double percent) {
    int range = highestRGB-lowestRGB;
    double valueDouble = lowestRGB + range*percent;
    return valueDouble.toInt();
  }
}
import 'package:flutter/material.dart';

class CustomThemes {
  static ThemeData darkMode = ThemeData(
    colorScheme: ColorScheme(
      primary: Colors.amber,
      onPrimary: Colors.white,
      secondary: Colors.teal,
      onSecondary: Colors.white,
      surface: Colors.grey.shade900,
      background: Colors.grey.shade900,
      error: Colors.red.shade400,
      onSurface: Colors.white,
      onBackground: Colors.white,
      onError: Colors.white,
      brightness: Brightness.dark,
    ),
    switchTheme: SwitchThemeData(
      thumbColor: MaterialStateProperty.resolveWith<Color>((states) {
        if (states.contains(MaterialState.selected)) {
          return Colors.amber;
        }
        return Colors.grey.shade600;
      }),
      trackColor: MaterialStateProperty.all(Colors.grey.shade500),
    ),
  );

  static ThemeData lightMode = ThemeData(
    colorScheme: ColorScheme(
      primary: Colors.amber,
      onPrimary: Colors.white,
      secondary: Colors.teal,
      onSecondary: Colors.white,
      surface: Colors.grey.shade900,
      background: Colors.grey.shade200,
      error: Colors.red.shade400,
      onSurface: Colors.black,
      onBackground: Colors.black,
      onError: Colors.white,
      brightness: Brightness.light,
    ),
    switchTheme: SwitchThemeData(
      thumbColor: MaterialStateProperty.resolveWith<Color>((states) {
        if (states.contains(MaterialState.selected)) {
          return Colors.amber;
        }
        return Colors.grey.shade600;
      }),
      trackColor: MaterialStateProperty.all(Colors.grey.shade500),
    ),
  );
}

import 'dart:collection';

import 'package:firebase_database/firebase_database.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:wellbeing/providers_and_settings/keys_for_save_and_load.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';



class DataWrapper {
    DataWrapper({
        this.activityTypeCollection,
        this.activityEntries,
        this.favoriteActivityTypes,
        this.hiddenActivityTypes,
        this.appSettings,
    });

    ActivityTypeCollection? activityTypeCollection;
    List<ActivityEntry>? activityEntries;
    Set<String>? favoriteActivityTypes;
    Set<String>? hiddenActivityTypes;
    AppSettings? appSettings;

    DataWrapper.fromSharedPreferences(SharedPreferences prefs) {
      final String? settingsString = prefs.getString(settingsKey);
      if (settingsString != null) {
          final Map<String, dynamic> settingsMap = jsonDecode(settingsString) as Map<String, dynamic>;
          appSettings = convertAppSettings(settingsMap);
      }

      final String? activityTypesString = prefs.getString(activityTypesKey);
      if (activityTypesString != null) {
        final Map<String, dynamic> activityTypesMap = jsonDecode(activityTypesString);
        activityTypeCollection = convertActivityTypeCollection(activityTypesMap);
      }

      final List<String>? activityEntriesStringList = prefs.getStringList(activityEntriesKey);
      if (activityEntriesStringList != null) {
        activityEntries = convertActivityEntries(activityEntriesStringList);
      }

      final List<String>? hiddenActivityTypesStringList = prefs.getStringList(hiddenActivityTypesKey);
      if (hiddenActivityTypesStringList != null) {
        hiddenActivityTypes = convertHiddenActivityTypes(hiddenActivityTypesStringList);
      }

      final List<String>? favoriteActivityTypesStringList = prefs.getStringList(favoriteActivityTypesKey);
      if (favoriteActivityTypesStringList != null) {
        favoriteActivityTypes = convertFavoriteActivityTypes(favoriteActivityTypesStringList);
      }
    }

    static Future<DataWrapper> fromFirebase(FirebaseDatabase db, rootPath) async {
      final DataSnapshot settingsSnapshot = await db.ref('$rootPath/$settingsKey').get();
      final DataSnapshot activityTypesSnapshot = await db.ref('$rootPath/$activityTypesKey').get();
      final DataSnapshot activityEntriesSnapshot = await db.ref('$rootPath/$activityEntriesKey').get();
      final DataSnapshot hiddenActivityTypesSnapshot = await db.ref('$rootPath/$hiddenActivityTypesKey').get();
      final DataSnapshot favoriteActivityTypesSnapshot = await db.ref('$rootPath/$favoriteActivityTypesKey').get();

      return DataWrapper._fromFirebase(
        settingsSnapshot: settingsSnapshot,
        activityTypesSnapshot: activityTypesSnapshot,
        activityEntriesSnapshot: activityEntriesSnapshot,
        hiddenActivityTypesSnapshot: hiddenActivityTypesSnapshot,
        favoriteActivityTypesSnapshot: favoriteActivityTypesSnapshot,
      );
    }

    DataWrapper._fromFirebase({
      required DataSnapshot settingsSnapshot,
      required DataSnapshot activityTypesSnapshot,
      required DataSnapshot activityEntriesSnapshot,
      required DataSnapshot hiddenActivityTypesSnapshot,
      required DataSnapshot favoriteActivityTypesSnapshot,
    }) {
      if (settingsSnapshot.exists) {
          if (activityTypesSnapshot.value != null) {
            final Map<String, dynamic> settingsMap = Map<String, dynamic>.from(settingsSnapshot.value as Map);
            appSettings = convertAppSettings(settingsMap);
          }
      }
      
      if (activityTypesSnapshot.exists) {
          if (activityTypesSnapshot.value != null) {
            final Map<String, dynamic> activityTypesMap = Map<String, dynamic>.from(activityTypesSnapshot.value as Map);
            activityTypeCollection = convertActivityTypeCollection(activityTypesMap);
          }
      }
      
      if (activityEntriesSnapshot.exists) {
          final List<dynamic>? activityEntriesStringList = activityEntriesSnapshot.value as List<dynamic>?;
          if (activityEntriesStringList != null) {
            activityEntries = convertActivityEntries(activityEntriesStringList);
          }
      }
      
      if (hiddenActivityTypesSnapshot.exists) {
          final List<dynamic>? hiddenActivityTypesStringList = hiddenActivityTypesSnapshot.value as List<dynamic>?;
          if (hiddenActivityTypesStringList != null) {
            hiddenActivityTypes = convertHiddenActivityTypes(hiddenActivityTypesStringList);
          }

      }
      
      if (favoriteActivityTypesSnapshot.exists) {
          final List<dynamic>? favoriteActivityTypesStringList = favoriteActivityTypesSnapshot.value as List<dynamic>?;
          if (favoriteActivityTypesStringList != null) {
            favoriteActivityTypes = convertFavoriteActivityTypes(favoriteActivityTypesStringList);
          }
      }
    }

    void loadToProviders(Reader stateProvider) {
      if (appSettings != null) {
        stateProvider(appSettingsProvider.state).state = appSettings!;
      } else {
        stateProvider(appSettingsProvider.state).state = AppSettings.defaultSettings();
      }

      if (activityTypeCollection != null) {
        stateProvider(activityTypeCollectionProvider.state).state = activityTypeCollection!;
      } else {
        stateProvider(activityTypeCollectionProvider.state).state = ActivityTypeCollection({});
      }

      if (activityEntries != null) {
        stateProvider(activityEntriesProvider.state).state = activityEntries!;
      } else {
        stateProvider(activityEntriesProvider.state).state = [];
      }

      if (favoriteActivityTypes != null) {
        stateProvider(favoriteActivityTypesProvider.state).state = favoriteActivityTypes!;
      } else {
        stateProvider(favoriteActivityTypesProvider.state).state = {};
      }

      if (hiddenActivityTypes != null) {
        stateProvider(hiddenActivityTypesProvider.state).state = hiddenActivityTypes!;
      } else {
        stateProvider(hiddenActivityTypesProvider.state).state = {};
      }
    }


    AppSettings convertAppSettings(Map<String, dynamic> settingsMap) {
      return AppSettings.fromMap(settingsMap);
    }

    ActivityTypeCollection convertActivityTypeCollection(Map<String, dynamic> activityTypeCollectionMap) {
      final Map<String, ActivityType> activityTypesMapConverted = activityTypeCollectionMap
          .map((key, value) => MapEntry(key, ActivityType.fromMap(Map<String, dynamic>.from(value as Map))));
      return ActivityTypeCollection(activityTypesMapConverted);
    }

    List<ActivityEntry> convertActivityEntries(List<dynamic> activityEntriesList) {
      return activityEntriesList
        .map(((e) => jsonDecode(e) as Map<String, dynamic>))
        .map((e) => ActivityEntry.fromMap(e)).toList();
    }

    Set<String> convertFavoriteActivityTypes(List<dynamic> favoriteActivityTypesList) {
      return favoriteActivityTypesList
        .map((e) => e as String)
        .toSet();
    }

    Set<String> convertHiddenActivityTypes(List<dynamic> hiddenActivityTypesList) {
      return hiddenActivityTypesList
        .map((e) => e as String)
        .toSet();
    }

    Future<void> saveDataToSharedPreferences() async {
      await activityTypeCollection?.saveToSharedPreferences();
      if (activityEntries != null) {
        await saveEntriesToSharedPreferences(activityEntries!);
      }
      if (favoriteActivityTypes != null) {
        await saveFavoriteActivityTypesToSharedPreferences(favoriteActivityTypes!);
      }
      if (hiddenActivityTypes != null) {
        await saveHiddenActivityTypesToSharedPreferences(hiddenActivityTypes!);
      }
      await appSettings?.saveToSharedPreferences();
    }

    void saveDataToFirebaseWithId(stateReader) {
      activityTypeCollection?.saveToFirebaseWithId(stateReader);
      if (activityEntries != null) {
        saveEntriesToFirebaseWithId(activityEntries!, stateReader);
      }
      if (favoriteActivityTypes != null) {
        saveFavoriteActivityTypesToFirebaseWithId(favoriteActivityTypes!, stateReader);
      }
      if (hiddenActivityTypes != null) {
        saveHiddenActivityTypesToFirebaseWithId(hiddenActivityTypes!, stateReader);
      }
      appSettings?.saveToFirebaseWithId(stateReader);
    }
    
    Future<void> saveDataToSharedPreferencesAndFirebaseWithId(Reader stateReader) async {
      await saveDataToSharedPreferences();
      saveDataToFirebaseWithId(stateReader);
    }


}import 'package:flutter/material.dart';

final List<IconData> iconList = [
  Icons.question_mark,
  Icons.lens,
  Icons.circle,
  Icons.one_k,
  Icons.two_k,
  Icons.three_k,
  Icons.four_k,
  Icons.five_k,
  Icons.six_k,
  Icons.seven_k,
  Icons.eight_k,
  Icons.nine_k,
  Icons.ten_k,
  Icons.onetwothree,
  Icons.eighteen_up_rating,
  Icons.one_x_mobiledata,
  Icons.thirty_fps,
  Icons.threesixty,
  Icons.three_p,
  Icons.sixty_fps,
  Icons.six_ft_apart,
  Icons.abc,
  Icons.ac_unit,
  Icons.access_alarm,
  Icons.access_time,
  Icons.accessibility,
  Icons.accessible,
  Icons.accessible_forward,
  Icons.account_balance,
  Icons.account_balance_wallet,
  Icons.account_circle,
  Icons.adb,
  Icons.add_circle_outline,
  Icons.add_comment,
  Icons.add_location,
  Icons.adjust,
  Icons.ads_click,
  Icons.agriculture,
  Icons.air,
  Icons.airline_seat_individual_suite,
  Icons.airline_stops,
  Icons.airplanemode_off,
  Icons.airplanemode_on,
  Icons.airplay,
  Icons.airport_shuttle,
  Icons.album,
  Icons.all_inclusive,
  Icons.alt_route,
  Icons.alternate_email,
  Icons.analytics,
  Icons.anchor,
  Icons.announcement,
  Icons.apartment,
  Icons.apple,
  Icons.architecture,
  Icons.archive,
  Icons.arrow_circle_down,
  Icons.arrow_circle_up,
  Icons.arrow_back,
  Icons.arrow_forward,
  Icons.arrow_downward,
  Icons.arrow_upward,
  Icons.article,
  Icons.assistant_navigation,
  Icons.attach_money,
  Icons.attachment,
  Icons.audiotrack,
  Icons.auto_awesome,
  Icons.auto_stories,
  Icons.autorenew,
  Icons.baby_changing_station,
  Icons.back_hand,
  Icons.backpack,
  Icons.backspace,
  Icons.backup,
  Icons.balance,
  Icons.bathtub,
  Icons.battery_alert,
  Icons.battery_charging_full,
  Icons.battery_full,
  Icons.beach_access,
  Icons.bedroom_baby,
  Icons.bedroom_child,
  Icons.bedroom_parent,
  Icons.bedtime,
  Icons.bike_scooter,
  Icons.blender,
  Icons.block_flipped,
  Icons.blur_circular,
  Icons.blur_on,
  Icons.bolt,
  Icons.book,
  Icons.bookmark,
  Icons.bookmark_added,
  Icons.border_all,
  Icons.boy,
  Icons.brightness_high,
  Icons.broken_image,
  Icons.browse_gallery,
  Icons.brunch_dining,
  Icons.brush,
  Icons.bubble_chart,
  Icons.bug_report,
  Icons.build_circle,
  Icons.bungalow,
  Icons.business,
  Icons.business_center,
  Icons.cable,
  Icons.cached,
  Icons.cake,
  Icons.calculate,
  Icons.calendar_today,
  Icons.calendar_view_day,
  Icons.calendar_view_month,
  Icons.calendar_view_week,
  Icons.call,
  Icons.call_merge,
  Icons.call_missed,
  Icons.call_missed_outgoing,
  Icons.call_received,
  Icons.call_split,
  Icons.camera,
  Icons.camera_alt,
  Icons.campaign,
  Icons.cancel,
  Icons.candlestick_chart,
  Icons.card_giftcard,
  Icons.card_travel,
  Icons.carpenter,
  Icons.cast,
  Icons.castle,
  Icons.catching_pokemon,
  Icons.category,
  Icons.celebration,
  Icons.center_focus_strong,
  Icons.chair,
  Icons.change_circle,
  Icons.change_history,
  Icons.chat,
  Icons.check_circle,
  Icons.checklist,
  Icons.checkroom,
  Icons.chevron_left,
  Icons.chevron_right,
  Icons.child_care,
  Icons.chrome_reader_mode,
  Icons.church,
  Icons.clean_hands,
  Icons.cleaning_services,
  Icons.clear,
  Icons.clear_all,
  Icons.close,
  Icons.close_fullscreen,
  Icons.cloud,
  Icons.cloudy_snowing,
  Icons.co_present,
  Icons.code,
  Icons.coffee,
  Icons.color_lens,
  Icons.colorize,
  Icons.commit,
  Icons.commute,
  Icons.compare_arrows,
  Icons.computer,
  Icons.connect_without_contact,
  Icons.connecting_airports,
  Icons.construction,
  Icons.contact_support,
  Icons.contactless,
  Icons.content_paste,
  Icons.contrast,
  Icons.cookie,
  Icons.copyright,
  Icons.coronavirus, 
  Icons.cottage,
  Icons.create,
  Icons.crib,
  Icons.crisis_alert,
  Icons.crop_din,
  Icons.cruelty_free,
  Icons.css,
  Icons.currency_bitcoin,
  Icons.currency_exchange,
  Icons.currency_franc,
  Icons.currency_lira,
  Icons.currency_pound,
  Icons.currency_ruble,
  Icons.currency_rupee,
  Icons.currency_yen,
  Icons.currency_yuan,
  Icons.cut,
  Icons.cyclone,
  Icons.dangerous,
  Icons.dark_mode,
  Icons.dashboard,
  Icons.data_array,
  Icons.data_exploration,
  Icons.data_object,
  Icons.data_saver_off,
  Icons.deblur,
  Icons.deck,
  Icons.dehaze,
  Icons.delete,
  Icons.delivery_dining,
  Icons.description,
  Icons.design_services,
  Icons.desk,
  Icons.desktop_mac,
  Icons.desktop_windows,
  Icons.device_hub,
  Icons.device_thermostat,
  Icons.devices,
  Icons.dialpad,
  Icons.diamond,
  Icons.dining,
  Icons.dinner_dining,
  Icons.directions,
  Icons.directions_bike,
  Icons.directions_boat_filled,
  Icons.directions_bus_filled,
  Icons.directions_car_filled,
  Icons.directions_railway_filled,
  Icons.directions_run,
  Icons.directions_subway_filled,
  Icons.directions_train,
  Icons.directions_walk,
  Icons.disabled_by_default,
  Icons.discord,
  Icons.discount,
  Icons.do_not_disturb,
  Icons.domain,
  Icons.done,
  Icons.done_all,
  Icons.donut_small,
  Icons.door_front_door,
  Icons.double_arrow,
  Icons.downhill_skiing,
  Icons.download_for_offline,
  Icons.drafts,
  Icons.draw,
  Icons.dry,
  Icons.dry_cleaning,
  Icons.duo,
  Icons.earbuds,
  Icons.edit,
  Icons.egg,
  Icons.eject,
  Icons.elderly,
  Icons.elderly_woman,
  Icons.electric_bike,
  Icons.electric_bolt,
  Icons.electric_car,
  Icons.electric_meter,
  Icons.electric_moped,
  Icons.electric_scooter,
  Icons.electrical_services,
  Icons.email,
  Icons.emergency,
  Icons.emoji_emotions,
  Icons.emoji_events,
  Icons.emoji_flags,
  Icons.emoji_food_beverage,
  Icons.emoji_nature,
  Icons.emoji_objects,
  Icons.emoji_people,
  Icons.engineering,
  Icons.error,
  Icons.escalator_warning,
  Icons.euro_symbol,
  Icons.event_seat,
  Icons.exit_to_app,
  Icons.expand_less,
  Icons.expand_more,
  Icons.explicit,
  Icons.explore,
  Icons.exposure,
  Icons.exposure_zero,
  Icons.extension,
  Icons.face,
  Icons.facebook,
  Icons.factory,
  Icons.family_restroom,
  Icons.fast_forward,
  Icons.fast_rewind,
  Icons.fastfood,
  Icons.favorite,
  Icons.featured_video,
  Icons.female,
  Icons.festival,
  Icons.fiber_new,
  Icons.fiber_smart_record,
  Icons.file_upload,
  Icons.filter,
  Icons.filter_alt,
  Icons.filter_hdr,
  Icons.filter_vintage,
  Icons.find_in_page,
  Icons.fingerprint,
  Icons.fire_extinguisher,
  Icons.fire_hydrant_alt,
  Icons.fire_truck,
  Icons.fireplace,
  Icons.first_page,
  Icons.fit_screen,
  Icons.fitbit,
  Icons.fitness_center,
  Icons.flag,
  Icons.flare,
  Icons.flash_on,
  Icons.flashlight_on,
  Icons.flatware,
  Icons.flight_class,
  Icons.flight_land,
  Icons.flight_takeoff,
  Icons.flourescent,
  Icons.folder,
  Icons.follow_the_signs,
  Icons.font_download,
  Icons.food_bank,
  Icons.forest,
  Icons.fork_left,
  Icons.fork_right,
  Icons.format_bold,
  Icons.format_color_fill,
  Icons.format_italic,
  Icons.format_list_bulleted,
  Icons.format_list_numbered,
  Icons.format_paint,
  Icons.format_quote,
  Icons.fort,
  Icons.forum,
  Icons.forward,
  Icons.free_breakfast,
  Icons.front_hand,
  Icons.functions,
  Icons.g_translate,
  Icons.gamepad,
  Icons.garage,
  Icons.gavel,
  Icons.gesture,
  Icons.gif_box,
  Icons.girl,
  Icons.golf_course,
  Icons.gpp_good,
  Icons.gps_fixed,
  Icons.grade,
  Icons.gradient,
  Icons.grass,
  Icons.grid_goldenratio,
  Icons.grid_view,
  Icons.group,
  Icons.group_work,
  Icons.groups,
  Icons.hail,
  Icons.handshake,
  Icons.handyman,
  Icons.hardware,
  Icons.hd,
  Icons.hdr_auto,
  Icons.headphones,
  Icons.healing,
  Icons.health_and_safety,
  Icons.hearing,
  Icons.heart_broken,
  Icons.height,
  Icons.help,
  Icons.hexagon,
  Icons.highlight,
  Icons.highlight_remove,
  Icons.hiking,
  Icons.history,
  Icons.history_edu,
  Icons.hive,
  Icons.home_repair_service,
  Icons.hotel,
  Icons.hotel_class,
  Icons.hourglass_bottom,
  Icons.house,
  Icons.html,
  Icons.https,
  Icons.hub,
  Icons.ice_skating,
  Icons.icecream,
  Icons.image,
  Icons.import_contacts,
  Icons.import_export,
  Icons.inbox,
  Icons.incomplete_circle,
  Icons.indeterminate_check_box,
  Icons.info,
  Icons.input,
  Icons.insert_chart,
  Icons.insert_emoticon,
  Icons.insights,
  Icons.invert_colors,
  Icons.iron,
  Icons.javascript,
  Icons.join_right,
  Icons.kayaking,
  Icons.key,
  Icons.keyboard,
  Icons.keyboard_control,
  Icons.keyboard_voice,
  Icons.king_bed,
  Icons.kitchen,
  Icons.kitesurfing,
  Icons.label,
  Icons.label_important,
  Icons.lan,
  Icons.landscape,
  Icons.language,
  Icons.laptop_windows,
  Icons.last_page,
  Icons.layers,
  Icons.library_music,
  Icons.light,
  Icons.light_mode,
  Icons.lightbulb,
  Icons.link,
  Icons.liquor,
  Icons.live_tv,
  Icons.living,
  Icons.local_activity,
  Icons.local_bar,
  Icons.local_cafe,
  Icons.local_dining,
  Icons.local_drink,
  Icons.local_fire_department,
  Icons.local_florist,
  Icons.local_gas_station,
  Icons.local_grocery_store,
  Icons.local_hotel,
  Icons.local_laundry_service,
  Icons.local_library,
  Icons.local_mall,
  Icons.local_movies,
  Icons.local_offer,
  Icons.local_parking,
  Icons.local_pharmacy,
  Icons.local_phone,
  Icons.local_pizza,
  Icons.local_police,
  Icons.local_post_office,
  Icons.local_print_shop,
  Icons.local_shipping,
  Icons.local_taxi,
  Icons.location_searching,
  Icons.lock,
  Icons.lock_open,
  Icons.login,
  Icons.logout,
  Icons.logo_dev,
  Icons.looks,
  Icons.looks_one,
  Icons.looks_two,
  Icons.loop,
  Icons.luggage,
  Icons.lunch_dining,
  Icons.male,
  Icons.man,
  Icons.manage_search,
  Icons.map,
  Icons.masks,
  Icons.medical_services,
  Icons.medication,
  Icons.menu_book,
  Icons.merge_type,
  Icons.mic,
  Icons.mic_external_on,
  Icons.military_tech,
  Icons.miscellaneous_services,
  Icons.mode_night,
  Icons.mode_standby,
  Icons.monetization_on,
  Icons.money,
  Icons.money_off,
  Icons.monitor_heart,
  Icons.monitor_weight,
  Icons.mood,
  Icons.mood_bad,
  Icons.moped,
  Icons.more_horiz,
  Icons.more_vert,
  Icons.mosque,
  Icons.motorcycle,
  Icons.mouse,
  Icons.move_down,
  Icons.move_up,
  Icons.movie,
  Icons.mp,
  Icons.multitrack_audio,
  Icons.museum,
  Icons.music_note,
  Icons.my_location,
  Icons.nat,
  Icons.nature,
  Icons.nature_people,
  Icons.near_me,
  Icons.nest_cam_wired_stand,
  Icons.network_cell,
  Icons.network_ping,
  Icons.network_wifi,
  Icons.new_releases,
  Icons.newspaper,
  Icons.next_plan,
  Icons.next_week,
  Icons.night_shelter,
  Icons.nightlife,
  Icons.nightlight,
  Icons.nightlight_round,
  Icons.noise_aware,
  Icons.noise_control_off,
  Icons.nordic_walking,
  Icons.north,
  Icons.north_east,
  Icons.north_west,
  Icons.notifications,
  Icons.now_widgets,
  Icons.numbers,
  Icons.oil_barrel,
  Icons.ondemand_video,
  Icons.opacity,
  Icons.open_in_full,
  Icons.open_in_new,
  Icons.open_with,
  Icons.other_houses,
  Icons.outbond,
  Icons.outdoor_grill,
  Icons.outlet,
  Icons.palette,
  Icons.pan_tool,
  Icons.pan_tool_alt,
  Icons.panorama,
  Icons.panorama_fish_eye,
  Icons.panorama_horizontal_select,
  Icons.panorama_photosphere_select,
  Icons.panorama_vertical_select,
  Icons.panorama_wide_angle_select,
  Icons.paragliding,
  Icons.park,
  Icons.password,
  Icons.paste,
  Icons.pause_circle,
  Icons.payment,
  Icons.paypal,
  Icons.pedal_bike,
  Icons.pending,
  Icons.pentagon,
  Icons.percent,
  Icons.person,
  Icons.pest_control,
  Icons.pest_control_rodent,
  Icons.pets,
  Icons.phishing,
  Icons.phonelink,
  Icons.phonelink_ring,
  Icons.photo_camera,
  Icons.php,
  Icons.piano,
  Icons.picture_as_pdf,
  Icons.pie_chart,
  Icons.pin,
  Icons.pivot_table_chart,
  Icons.pix,
  Icons.plagiarism,
  Icons.play_circle,
  Icons.plumbing,
  Icons.plus_one,
  Icons.podcasts,
  Icons.point_of_sale,
  Icons.policy,
  Icons.polyline,
  Icons.polymer,
  Icons.pool,
  Icons.power,
  Icons.power_input,
  Icons.power_settings_new,
  Icons.precision_manufacturing,
  Icons.pregnant_woman,
  Icons.price_check,
  Icons.print,
  Icons.priority_high,
  Icons.production_quantity_limits,
  Icons.propane,
  Icons.propane_tank,
  Icons.psychology,
  Icons.public,
  Icons.published_with_changes,
  Icons.push_pin,
  Icons.query_stats,
  Icons.queue_music,
  Icons.quora,
  Icons.radar,
  Icons.radio,
  Icons.radio_button_checked,
  Icons.ramen_dining,
  Icons.raw_on,
  Icons.real_estate_agent,
  Icons.receipt_long,
  Icons.recommend,
  Icons.record_voice_over,
  Icons.rectangle,
  Icons.recycling,
  Icons.reddit,
  Icons.redeem,
  Icons.redo,
  Icons.refresh,
  Icons.remove_circle,
  Icons.remove_red_eye,
  Icons.reorder,
  Icons.repeat_on,
  Icons.repeat_one_on,
  Icons.replay_circle_filled,
  Icons.reply,
  Icons.reply_all,
  Icons.report,
  Icons.restaurant,
  Icons.rice_bowl,
  Icons.rocket,
  Icons.rocket_launch,
  Icons.roller_skating,
  Icons.roofing,
  Icons.room,
  Icons.room_service,
  Icons.rotate_left,
  Icons.rotate_right,
  Icons.route,
  Icons.rowing,
  Icons.rtt,
  Icons.rule,
  Icons.run_circle,
  Icons.safety_divider,
  Icons.sailing,
  Icons.sanitizer,
  Icons.satellite_alt,
  Icons.save,
  Icons.saved_search,
  Icons.savings,
  Icons.scale,
  Icons.scanner,
  Icons.scatter_plot,
  Icons.schema,
  Icons.school,
  Icons.science,
  Icons.scoreboard,
  Icons.screen_rotation,
  Icons.screen_rotation_alt,
  Icons.scuba_diving,
  Icons.sd,
  Icons.sd_card,
  Icons.search,
  Icons.security,
  Icons.self_improvement,
  Icons.send,
  Icons.sensor_occupied,
  Icons.sentiment_dissatisfied,
  Icons.sentiment_neutral,
  Icons.sentiment_satisfied,
  Icons.sentiment_satisfied_alt,
  Icons.sentiment_very_dissatisfied,
  Icons.sentiment_very_satisfied,
  Icons.set_meal,
  Icons.settings,
  Icons.settings_accessibility,
  Icons.settings_ethernet,
  Icons.settings_input_antenna,
  Icons.settings_input_svideo,
  Icons.settings_overscan,
  Icons.settings_power,
  Icons.settings_suggest,
  Icons.shopping_cart,
  Icons.shower,
  Icons.shuffle_on,
  Icons.sick,
  Icons.sign_language,
  Icons.signpost,
  Icons.sip,
  Icons.skateboarding,
  Icons.sledding,
  Icons.slideshow,
  Icons.smart_screen,
  Icons.smartphone,
  Icons.smoke_free,
  Icons.smoking_rooms,
  Icons.sms,
  Icons.snapchat,
  Icons.snowboarding,
  Icons.snowing,
  Icons.snowmobile,
  Icons.snowshoeing,
  Icons.social_distance,
  Icons.solar_power,
  Icons.sort_by_alpha,
  Icons.sos,
  Icons.soup_kitchen,
  Icons.south_america,
  Icons.south_east,
  Icons.south_west,
  Icons.spa,
  Icons.space_bar,
  Icons.space_dashboard,
  Icons.speaker,
  Icons.speed,
  Icons.splitscreen,
  Icons.spoke,
  Icons.sports,
  Icons.sports_bar,
  Icons.sports_baseball,
  Icons.sports_basketball,
  Icons.sports_cricket,
  Icons.sports_esports,
  Icons.sports_football,
  Icons.sports_golf,
  Icons.sports_gymnastics,
  Icons.sports_handball,
  Icons.sports_hockey,
  Icons.sports_kabaddi,
  Icons.sports_martial_arts,
  Icons.sports_mma,
  Icons.sports_motorsports,
  Icons.sports_rugby,
  Icons.sports_score,
  Icons.sports_soccer,
  Icons.sports_tennis,
  Icons.sports_volleyball,
  Icons.square,
  Icons.square_foot,
  Icons.ssid_chart,
  Icons.stadium,
  Icons.stairs,
  Icons.star,
  Icons.stars,
  Icons.start,
  Icons.stop,
  Icons.stop_circle,
  Icons.storage,
  Icons.store,
  Icons.storefront,
  Icons.storm,
  Icons.straighten,
  Icons.stream,
  Icons.stroller,
  Icons.style,
  Icons.subdirectory_arrow_left,
  Icons.subdirectory_arrow_right,
  Icons.subtitles,
  Icons.sunny,
  Icons.sunny_snowing,
  Icons.superscript,
  Icons.supervised_user_circle,
  Icons.support_agent,
  Icons.surfing,
  Icons.swap_calls,
  Icons.swap_horizontal_circle,
  Icons.swap_vert_circle,
  Icons.switch_left,
  Icons.switch_right,
  Icons.synagogue,
  Icons.sync,
  Icons.table_bar,
  Icons.table_chart,
  Icons.tag,
  Icons.tag_faces,
  Icons.takeout_dining,
  Icons.tapas,
  Icons.task_alt,
  Icons.telegram,
  Icons.temple_buddhist,
  Icons.temple_hindu,
  Icons.terminal,
  Icons.terrain,
  Icons.texture,
  Icons.theater_comedy,
  Icons.theaters,
  Icons.thermostat,
  Icons.thumb_down,
  Icons.thumb_up,
  Icons.thumbs_up_down,
  Icons.thunderstorm,
  Icons.tiktok,
  Icons.timelapse,
  Icons.timeline,
  Icons.timer,
  Icons.tips_and_updates,
  Icons.tire_repair,
  Icons.toggle_on,
  Icons.token,
  Icons.toll,
  Icons.tonality,
  Icons.tornado,
  Icons.tour,
  Icons.toys,
  Icons.track_changes,
  Icons.traffic,
  Icons.transfer_within_a_station,
  Icons.transform,
  Icons.transgender,
  Icons.translate,
  Icons.travel_explore,
  Icons.trending_down,
  Icons.trending_up,
  Icons.trip_origin,
  Icons.troubleshoot,
  Icons.tsunami,
  Icons.tune,
  Icons.tungsten,
  Icons.turn_left,
  Icons.turn_right,
  Icons.turn_slight_left,
  Icons.turn_slight_right,
  Icons.two_wheeler,
  Icons.u_turn_left,
  Icons.u_turn_right,
  Icons.umbrella,
  Icons.usb,
  Icons.vaccines,
  Icons.vape_free,
  Icons.vaping_rooms,
  Icons.verified,
  Icons.vertical_align_top,
  Icons.vertical_shades_closed,
  Icons.vertical_split,
  Icons.vibration,
  Icons.video_stable,
  Icons.videocam,
  Icons.videogame_asset,
  Icons.view_carousel,
  Icons.view_column,
  Icons.view_comfortable,
  Icons.view_comfy_alt,
  Icons.view_compact,
  Icons.view_compact_alt,
  Icons.view_cozy,
  Icons.view_day,
  Icons.view_headline,
  Icons.view_in_ar,
  Icons.view_week,
  Icons.vignette,
  Icons.visibility,
  Icons.volcano,
  Icons.volume_down,
  Icons.volume_mute,
  Icons.volume_off,
  Icons.volume_up,
  Icons.volunteer_activism,
  Icons.vpn_key,
  Icons.wallet,
  Icons.wallet_travel,
  Icons.warning,
  Icons.wash,
  Icons.watch,
  Icons.water,
  Icons.water_drop,
  Icons.waving_hand,
  Icons.wb_twighlight,
  Icons.wb_twilight,
  Icons.wc,
  Icons.web_stories,
  Icons.webhook,
  Icons.wechat,
  Icons.weekend,
  Icons.west,
  Icons.whatsapp,
  Icons.whatshot,
  Icons.wheelchair_pickup,
  Icons.wifi,
  Icons.wifi_protected_setup,
  Icons.wifi_tethering,
  Icons.wind_power,
  Icons.window,
  Icons.wine_bar,
  Icons.woman,
  Icons.wordpress,
  Icons.work,
  Icons.workspace_premium,
  Icons.workspaces,
  Icons.wrap_text,
  Icons.yard,
  Icons.zoom_in_map,
  Icons.zoom_out_map,
];// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyD-_1KXFtB21OjRuQJvpEiBgUYMdvndYcU',
    appId: '1:599276581158:web:c27870473f27e2be2291e7',
    messagingSenderId: '599276581158',
    projectId: 'wellbeing-d402b',
    authDomain: 'wellbeing-d402b.firebaseapp.com',
    storageBucket: 'wellbeing-d402b.appspot.com',
    measurementId: 'G-GE9EMZNP58',
    databaseURL: 'https://wellbeing-d402b-default-rtdb.europe-west1.firebasedatabase.app'
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBw6V80UlpEFS3fC7E2CprTH725bo0qUwU',
    appId: '1:599276581158:android:ff4cdfc813e739832291e7',
    messagingSenderId: '599276581158',
    projectId: 'wellbeing-d402b',
    storageBucket: 'wellbeing-d402b.appspot.com',
    databaseURL: 'https://wellbeing-d402b-default-rtdb.europe-west1.firebasedatabase.app'
  );
}
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wellbeing/components/pages/root.dart';
import 'package:flutter/services.dart';
import 'package:wellbeing/dataclasses/custom_themes.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:wellbeing/providers_and_settings/on_load.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();

  final container = ProviderContainer();
  container.read(loadDataProvider);

  runApp(UncontrolledProviderScope(
    container: container,
    child: const MyApp()
  )); 
}
  

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: SystemUiOverlay.values);

    final AppSettings appSettings = ref.watch(appSettingsProvider);
    final bool setDarkMode = appSettings.darkMode;
    final ThemeData themeToUse = setDarkMode
      ? CustomThemes.darkMode
      : CustomThemes.lightMode;

    return MaterialApp(
      title: 'Activity Logging',
      home: const Root(),
      theme: themeToUse,
      debugShowCheckedModeBanner: false,
    );
  }
}


// TODO reset password => Email
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:wellbeing/providers_and_settings/settings.dart';
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:wellbeing/dataclasses/data_wrapper.dart';
import 'package:wellbeing/providers_and_settings/keys_for_save_and_load.dart';

class DataLoader {
  DataLoader(this.stateReader);
  final Reader stateReader;

  Future<void> loadFromSharedPrefs() async {
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final DataWrapper dataWrapper = DataWrapper.fromSharedPreferences(prefs);
    dataWrapper.loadToProviders(stateReader);
  }

  Future<void> loadFromFirebaseWithId(String userId) async {
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final FirebaseDatabase db = FirebaseDatabase.instance;
    final DataWrapper dataWrapper = await DataWrapper.fromFirebase(db, 'users/$userId');
    dataWrapper.loadToProviders(stateReader);
    dataWrapper.saveDataToSharedPreferencesAndFirebaseWithId(stateReader);
    prefs.setString(firebaseUserIdKey, userId);
  }

  Future<void> loadAndCombineSharedPreferencesAndFirebaseWithId(String userId) async {
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final DataWrapper dataWrapperSharedPreferences = DataWrapper.fromSharedPreferences(prefs);
    final FirebaseDatabase db = FirebaseDatabase.instance;
    final DataWrapper dataWrapperFirebase = await DataWrapper.fromFirebase(db, 'users/$userId');

    final AppSettings appSettingsFromSharedPreferences = dataWrapperSharedPreferences.appSettings ?? AppSettings.defaultSettings();

    final ActivityTypeCollection joinedActivityTypeCollection = ActivityTypeCollection({})
      .createAndReturnJoinedCollection(dataWrapperSharedPreferences.activityTypeCollection)
      .createAndReturnJoinedCollection(dataWrapperFirebase.activityTypeCollection);

    final List<ActivityEntry> joinedActivityEntries = joinEntryLists(
      dataWrapperSharedPreferences.activityEntries ?? [],
      dataWrapperFirebase.activityEntries ?? [],
    );

    final DataWrapper dataWrapperToApply = DataWrapper(
      appSettings: appSettingsFromSharedPreferences,
      activityTypeCollection: joinedActivityTypeCollection,
      activityEntries: joinedActivityEntries,
      favoriteActivityTypes: dataWrapperSharedPreferences.favoriteActivityTypes,
      hiddenActivityTypes: {}
    );

    dataWrapperToApply.loadToProviders(stateReader);
    dataWrapperToApply.saveDataToSharedPreferencesAndFirebaseWithId(stateReader);
    
    prefs.setString(firebaseUserIdKey, userId);
  }
}import 'package:firebase_database/firebase_database.dart';

void setValueToFirebase(String refPath, dynamic value) async {
  final FirebaseDatabase db = FirebaseDatabase.instance;
  final DatabaseReference dbRef = db.ref(refPath);
  dbRef.set(value);
}import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';  
import 'package:wellbeing/dataclasses/activity_entry.dart';
import 'package:wellbeing/providers_and_settings/keys_for_save_and_load.dart';
import 'package:wellbeing/dataclasses/activity_type.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:wellbeing/providers_and_settings/firebase_helpers.dart';




final DateTime today = DateTime.now();
final DateTime todayStart = DateTime(today.year, today.month, today.day);

// Activity Entries
final StateProvider<List<ActivityEntry>> activityEntriesProvider = StateProvider((ref) => [ ]);

void addActivityEntry(Reader stateReader) {
  String? activityTypeId = stateReader(activityTypeIdProvider);
  if (activityTypeId == null) return;

  final ActivityEntry newActivityType = ActivityEntry(
    activityTypeId: activityTypeId,
    date: stateReader(selectedDateProvider),
    durationInMinutes: stateReader(selectedDurationProvider),
    wellbeingScore: stateReader(wellbeingScoreProvider)
  );

  
  final List<ActivityEntry> previousState = stateReader(activityEntriesProvider);
  final List<ActivityEntry> newState = [...previousState, newActivityType];
  saveEntriesToSharedPreferencesAndFirebaseWithId(newState, stateReader);
  stateReader(activityEntriesProvider.state).state = newState;
  updateFavorites(stateReader);
}

// Activity Types and Favorites
final StateProvider<ActivityTypeCollection> activityTypeCollectionProvider = StateProvider((ref) => ActivityTypeCollection({}));


final StateProvider<Set<String>> hiddenActivityTypesProvider = StateProvider((ref) => {});

Future<void> saveHiddenActivityTypesToSharedPreferences(Set<String> hiddenActivityTypes) async {
  final SharedPreferences prefs = await SharedPreferences.getInstance();
  prefs.setStringList(hiddenActivityTypesKey, hiddenActivityTypes.toList());
}

void saveHiddenActivityTypesToFirebaseWithId(Set<String> hiddenActivityTypes, Reader stateReader)  {
    final String? userId = stateReader(userIdFirebaseProvider);
      if (userId != null) {
        setValueToFirebase('$usersKey/$userId/$hiddenActivityTypesKey', hiddenActivityTypes.toList());
    }
}

Future<void> saveHiddenActivityTypesToSharedPreferencesAndFirebaseWithId(Set<String> hiddenActivityTypes, Reader stateReader) async {
  await saveHiddenActivityTypesToSharedPreferences(hiddenActivityTypes);
  saveHiddenActivityTypesToFirebaseWithId(hiddenActivityTypes, stateReader);
}


final StateProvider<Set<String>> favoriteActivityTypesProvider = StateProvider((ref) => {});

Future<void> saveFavoriteActivityTypesToSharedPreferences(Set<String> favoriteActivityTypes) async {
  final SharedPreferences prefs = await SharedPreferences.getInstance();
  prefs.setStringList(favoriteActivityTypesKey, favoriteActivityTypes.toList());
}

void saveFavoriteActivityTypesToFirebaseWithId(Set<String> favoriteActivityTypes, Reader stateReader)  {
    final String? userId = stateReader(userIdFirebaseProvider);
      if (userId != null) {
        setValueToFirebase('$usersKey/$userId/$favoriteActivityTypesKey', favoriteActivityTypes.toList());
    }
}

Future setFavoriteActivityTypesToSharedPreferencesAndFirebaseWithId(Set<String> favoriteActivityTypes, Reader stateReader) async {
  await saveFavoriteActivityTypesToSharedPreferences(favoriteActivityTypes);
  saveFavoriteActivityTypesToFirebaseWithId(favoriteActivityTypes, stateReader);
}


void updateFavorites(Reader stateReader) {
  final List<ActivityEntry> activityEntries = stateReader(activityEntriesProvider);

  final Map<String, int> counterMap = activityEntries.fold(
    {},
    (Map<String, int> previousValue, ActivityEntry element) {
      if (!previousValue.keys.contains(element.activityTypeId)) {
        previousValue[element.activityTypeId] = 1;
      } else {
        previousValue[element.activityTypeId] = previousValue[element.activityTypeId]! + 1;
      }

      return previousValue;
    }
  );

  final List<List> counterList = counterMap
    .entries
    .map((e) => [e.key, e.value])
    .toList();
  
  counterList.sort((a, b) => b[1] - a[1]);

  final Set<String> favoriteActivityTypes = counterList
    .take(3)
    .map((e) => e[0] as String)
    .toSet();
  
  setFavoriteActivityTypesToSharedPreferencesAndFirebaseWithId(favoriteActivityTypes, stateReader);
  stateReader(favoriteActivityTypesProvider.state).state = favoriteActivityTypes;
}


// Activity Entry Creation
const int defaultDuration = 30;
final StateProvider<DateTime> selectedDateProvider = StateProvider((ref) => todayStart);
final StateProvider<int> selectedDurationProvider = StateProvider((ref) => defaultDuration);
final StateProvider<String> activityTypeNameInputProvider = StateProvider((ref) => '');
final StateProvider<String?> activityTypeIdProvider = StateProvider((ref) => '');


// Activity Type Creation
final StateProvider<IconData> iconProvider = StateProvider((ref) => Icons.question_mark);
final StateProvider<Color> colorProvider = StateProvider((ref) => Colors.red);


// Wellbeing Score
const double minWellbeingScore = 0;
const double maxWellbeingScore = 100;
const double middleWellbeingScore = (minWellbeingScore+maxWellbeingScore) / 2;
final StateProvider<double> wellbeingScoreProvider = StateProvider((ref) => middleWellbeingScore);



// Plot Providers
final StateProvider<Set<int>> timeScatterSelectedSpotsProvider = StateProvider((ref) => {});
final StateProvider<int> chartTypeIndexActivityProvider = StateProvider((ref) => 0);
final StateProvider<String?> activityTypeSelectedIdProvider = StateProvider((ref) => null);


// datefilter
final StateProvider<DateTimeRange?> dateRangeFilterProvider = StateProvider((ref) => null);
final StateProvider<DateTimeRange?> dateRangeSelectorProvider = StateProvider((ref) => null);

// Daterange Button Colors
final StateProvider<int> dateRangeButtonSelectedIndexProvider = StateProvider((ref) => 0);


// Daterange Bounds for Selection
final Provider<DateTimeRange> dateRangeForSelectionBounds = Provider(((ref) => DateTimeRange(
  start: DateTime(todayStart.year - 5, 01),
  end: DateTime(todayStart.year + 5, 12)
)));


// Icons for Tabs
const IconData iconDashboardSummaries = Icons.donut_large;
const IconData iconDashboardTypes = Icons.bar_chart;
const IconData iconEntryHistory = Icons.history;
const IconData iconTypeList = Icons.list;
const IconData iconTheoryHowTo = Icons.help;
const IconData iconSettings = Icons.settings;


final StateProvider<bool> userIsLoggedInProvider = StateProvider((ref) => true);
final StateProvider<String?> userIdFirebaseProvider = StateProvider((ref) => null);const String usersKey = 'users';

const String settingsKey = 'settings';
const String settingsDarkModeKey = 'darkMode';
const String settingsShowEyebrowsKey = 'showEyebrows';
const String settingsSmileyColorNegativeKey = 'smileyGradientColorNegative';
const String settingsSmileyColorPositiveKey = 'smileyGradientColorPositive';
const String settingsShowFavoriteActivitiesKey = 'showFavoriteActivities';

const String activityTypesKey = 'activityTypes';
const String activityEntriesKey = 'activityEntries';
const String hiddenActivityTypesKey = 'hiddenActivityTypes';
const String favoriteActivityTypesKey = 'favoriteActivityTypes';

const String firebaseUserIdKey = 'firebaseUserId';import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/providers_and_settings/keys_for_save_and_load.dart';
import 'package:wellbeing/providers_and_settings/data_loader.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:wellbeing/firebase_options.dart';
import 'package:shared_preferences/shared_preferences.dart';


final Provider<void> loadDataProvider = Provider((ref) async {
  final DataSetup dataSetup = DataSetup(ref.read);
  dataSetup.loadDataOnUserChange();
});

class DataSetup {
  DataSetup(this.stateReader);

  final Reader stateReader;
  User? user;

  void loadDataOnUserChange() async {
    FirebaseAuth auth = await startFirebaseAuthentification();

    auth
      .idTokenChanges()  // also triggers on app startup
      .listen((User? loadedUser) {
        user = loadedUser;
        onUserChange();
      });
  }

  Future<FirebaseAuth> startFirebaseAuthentification() async {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );

    final FirebaseAuth auth = FirebaseAuth.instance;
    return auth;
  }

  void onUserChange() async {
    if (user == null) {
      noUser();
    } else {
      userLogin();
    }
  }

  void noUser() {
    stateReader(userIsLoggedInProvider.state).state = false;
    stateReader(userIdFirebaseProvider.state).state = null;
  }

  void userLogin() async {
    final DataLoader dataLoader = DataLoader(stateReader);
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final String? firebaseUserIdFromSharedPreferences = prefs.getString(firebaseUserIdKey);
    final String userIdFromFirebase = user!.uid;  // force not null: function is only called after user == null

    print({  // TODO works in web not in android
      'firebaseUserIdFromSharedPreferences': firebaseUserIdFromSharedPreferences,
      'userIdFromFirebase': userIdFromFirebase,
    });

    if (firebaseUserIdFromSharedPreferences == null) { // save afterwards
      dataLoader.loadAndCombineSharedPreferencesAndFirebaseWithId(userIdFromFirebase);
    } else {
      dataLoader.loadFromFirebaseWithId(userIdFromFirebase);
    }

    stateReader(userIsLoggedInProvider.state).state = true;
    stateReader(userIdFirebaseProvider.state).state = user!.uid;  // force not null: function is only called after user == null
  }
}






import 'package:flutter/material.dart';
import 'package:wellbeing/providers_and_settings/keys_for_save_and_load.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:convert';
import 'package:wellbeing/providers_and_settings/general_providers.dart';
import 'package:wellbeing/providers_and_settings/firebase_helpers.dart';


class AppSettings {
  AppSettings({
    required this.showSmileyEyeBrows,
    required this.darkMode,
    required this.smileyGradientColorNegative,
    required this.smileyGradientColorPositive,
    required this.showFavoriteActivities,
  });

  bool showFavoriteActivities;
  bool showSmileyEyeBrows;
  bool darkMode;
  Color smileyGradientColorNegative;
  Color smileyGradientColorPositive;

  AppSettings.defaultSettings() : this(
      darkMode: true,
      showSmileyEyeBrows: true,
      showFavoriteActivities: true,
      smileyGradientColorNegative: Colors.red,
      smileyGradientColorPositive: Colors.green,
  );

  AppSettings.fromMap(Map<String, dynamic> map) :
    showSmileyEyeBrows = map[settingsShowEyebrowsKey],
    darkMode = map[settingsDarkModeKey],
    smileyGradientColorNegative = Color(map[settingsSmileyColorNegativeKey]),
    smileyGradientColorPositive = Color(map[settingsSmileyColorPositiveKey]),
    showFavoriteActivities = map[settingsShowFavoriteActivitiesKey];

  Map<String, dynamic> toMap() {
    return {
      settingsDarkModeKey: darkMode,
      settingsShowEyebrowsKey: showSmileyEyeBrows,
      settingsSmileyColorNegativeKey: smileyGradientColorNegative.value,
      settingsSmileyColorPositiveKey: smileyGradientColorPositive.value,
      settingsShowFavoriteActivitiesKey: showFavoriteActivities,
    };
  }

  String toJSONString() {
    return jsonEncode(toMap());
  }

  Future<void> saveToSharedPreferences() async {
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    prefs.setString(settingsKey, toJSONString());
  }

  void saveToFirebaseWithId(Reader stateReader) async {
    final String? userId = stateReader(userIdFirebaseProvider);
      if (userId != null) {
        setValueToFirebase('$usersKey/$userId/$settingsKey', toMap());
    }
  }

  Future<void> saveToSharedPreferencesAndFirebaseWithId(Reader stateReader) async {
    await saveToSharedPreferences();
    saveToFirebaseWithId(stateReader);
  }

  void updateShowSmileyEyeBrows(bool value, Reader stateReader) {
    showSmileyEyeBrows = value;
    updateToTheseSettings(stateReader);
  }

  void updateSetDarkMode(bool value, Reader stateReader) {
    darkMode = value;
    updateToTheseSettings(stateReader);
  }

  void updateShowFavoriteActivities(bool value, Reader stateReader) {
    showFavoriteActivities = value;
    updateToTheseSettings(stateReader);
  }

  void updateSmileyGradientColorNegative(Color value, Reader stateReader) {
    smileyGradientColorNegative = value;
    updateToTheseSettings(stateReader);
  }

  void updateSmileyGradientColorPositive(Color value, Reader stateReader) {
    smileyGradientColorPositive = value;
    updateToTheseSettings(stateReader);
  }

  void updateToTheseSettings(Reader stateReader) {
    final AppSettings newSettings = AppSettings.fromMap(toMap());
    stateReader(appSettingsProvider.state).state = newSettings;
  }
}

final StateProvider<AppSettings> appSettingsProvider = StateProvider((ref) => AppSettings.defaultSettings(),);
